<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <meta name="generator" content="sphinx-3.1.2, furo 2021.04.11.beta34"/>
        <title>sage.categories.category - Hodge diamond cutter v1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/styles/furo.css?digest=59ab60ac09ea94ccfe6deddff6d715cce948a6fc">
    <link rel="stylesheet" href="../../../_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="../../../_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="../../../_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Hodge diamond cutter v1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Hodge diamond cutter v1.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html">
  <input class="sidebar-search" placeholder=Search name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <h1>Source code for sage.categories.category</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">Categories</span>

<span class="sd">AUTHORS:</span>

<span class="sd">- David Kohel, William Stein and Nicolas M. Thiery</span>

<span class="sd">Every Sage object lies in a category. Categories in Sage are</span>
<span class="sd">modeled on the mathematical idea of category, and are distinct from</span>
<span class="sd">Python classes, which are a programming construct.</span>

<span class="sd">In most cases, typing ``x.category()`` returns the category to which ``x``</span>
<span class="sd">belongs. If ``C`` is a category and ``x`` is any object, ``C(x)`` tries to</span>
<span class="sd">make an object in ``C`` from ``x``. Checking if ``x`` belongs to ``C`` is done</span>
<span class="sd">as usually by ``x in C``.</span>

<span class="sd">See :class:`Category` and :mod:`sage.categories.primer` for more details.</span>

<span class="sd">EXAMPLES:</span>

<span class="sd">We create a couple of categories::</span>

<span class="sd">    sage: Sets()</span>
<span class="sd">    Category of sets</span>
<span class="sd">    sage: GSets(AbelianGroup([2,4,9]))</span>
<span class="sd">    Category of G-sets for Multiplicative Abelian group isomorphic to C2 x C4 x C9</span>
<span class="sd">    sage: Semigroups()</span>
<span class="sd">    Category of semigroups</span>
<span class="sd">    sage: VectorSpaces(FiniteField(11))</span>
<span class="sd">    Category of vector spaces over Finite Field of size 11</span>
<span class="sd">    sage: Ideals(IntegerRing())</span>
<span class="sd">    Category of ring ideals in Integer Ring</span>

<span class="sd">Let's request the category of some objects::</span>

<span class="sd">    sage: V = VectorSpace(RationalField(), 3)</span>
<span class="sd">    sage: V.category()</span>
<span class="sd">    Category of finite dimensional vector spaces with basis</span>
<span class="sd">     over (number fields and quotient fields and metric spaces)</span>

<span class="sd">    sage: G = SymmetricGroup(9)</span>
<span class="sd">    sage: G.category()</span>
<span class="sd">    Join of Category of finite enumerated permutation groups and</span>
<span class="sd">    Category of finite weyl groups and</span>
<span class="sd">    Category of well generated finite irreducible complex reflection groups</span>

<span class="sd">    sage: P = PerfectMatchings(3)</span>
<span class="sd">    sage: P.category()</span>
<span class="sd">    Category of finite enumerated sets</span>

<span class="sd">Let's check some memberships::</span>

<span class="sd">    sage: V in VectorSpaces(QQ)</span>
<span class="sd">    True</span>
<span class="sd">    sage: V in VectorSpaces(FiniteField(11))</span>
<span class="sd">    False</span>
<span class="sd">    sage: G in Monoids()</span>
<span class="sd">    True</span>
<span class="sd">    sage: P in Rings()</span>
<span class="sd">    False</span>

<span class="sd">For parametrized categories one can use the following shorthand::</span>

<span class="sd">    sage: V in VectorSpaces</span>
<span class="sd">    True</span>
<span class="sd">    sage: G in VectorSpaces</span>
<span class="sd">    False</span>

<span class="sd">A parent ``P`` is in a category ``C`` if ``P.category()`` is a subcategory of</span>
<span class="sd">``C``.</span>

<span class="sd">.. note::</span>

<span class="sd">    Any object of a category should be an instance of</span>
<span class="sd">    :class:`~sage.structure.category_object.CategoryObject`.</span>

<span class="sd">    For backward compatibility this is not yet enforced::</span>

<span class="sd">        sage: class A:</span>
<span class="sd">        ....:   def category(self):</span>
<span class="sd">        ....:       return Fields()</span>
<span class="sd">        sage: A() in Rings()</span>
<span class="sd">        True</span>

<span class="sd">    By default, the category of an element `x` of a parent `P` is the category</span>
<span class="sd">    of all objects of `P` (this is dubious an may be deprecated)::</span>

<span class="sd">        sage: V = VectorSpace(RationalField(), 3)</span>
<span class="sd">        sage: v = V.gen(1)</span>
<span class="sd">        sage: v.category()</span>
<span class="sd">        Category of elements of Vector space of dimension 3 over Rational Field</span>
<span class="sd">"""</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="c1"># ****************************************************************************</span>
<span class="c1">#  Copyright (C) 2005      David Kohel &lt;kohel@maths.usyd.edu&gt; and</span>
<span class="c1">#                          William Stein &lt;wstein@math.ucsd.edu&gt;</span>
<span class="c1">#                2008-2014 Nicolas M. Thiery &lt;nthiery at users.sf.net&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#                  https://www.gnu.org/licenses/</span>
<span class="c1"># ****************************************************************************</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">sage.misc.abstract_method</span> <span class="k">import</span> <span class="n">abstract_method</span><span class="p">,</span> <span class="n">abstract_methods_of_class</span>
<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="k">import</span> <span class="n">cached_method</span><span class="p">,</span> <span class="n">cached_function</span>
<span class="kn">from</span> <span class="nn">sage.misc.c3_controlled</span> <span class="k">import</span> <span class="n">_cmp_key</span><span class="p">,</span> <span class="n">_cmp_key_named</span><span class="p">,</span> <span class="n">C3_sorted_merge</span>
<span class="kn">from</span> <span class="nn">sage.misc.lazy_attribute</span> <span class="k">import</span> <span class="n">lazy_attribute</span>
<span class="kn">from</span> <span class="nn">sage.misc.unknown</span> <span class="k">import</span> <span class="n">Unknown</span>
<span class="kn">from</span> <span class="nn">sage.misc.weak_dict</span> <span class="k">import</span> <span class="n">WeakValueDictionary</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="k">import</span> <span class="n">SageObject</span>
<span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="k">import</span> <span class="n">UniqueRepresentation</span>
<span class="kn">from</span> <span class="nn">sage.structure.dynamic_class</span> <span class="k">import</span> <span class="n">DynamicMetaclass</span><span class="p">,</span> <span class="n">dynamic_class</span>

<span class="kn">from</span> <span class="nn">sage.categories.category_cy_helper</span> <span class="k">import</span> <span class="n">category_sort_key</span><span class="p">,</span> <span class="n">_sort_uniq</span><span class="p">,</span> <span class="n">_flatten_categories</span><span class="p">,</span> <span class="n">join_as_tuple</span>

<span class="n">_join_cache</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Category</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    The base class for modeling mathematical categories, like for example:</span>

<span class="sd">    - ``Groups()``: the category of groups</span>
<span class="sd">    - ``EuclideanDomains()``: the category of euclidean rings</span>
<span class="sd">    - ``VectorSpaces(QQ)``: the category of vector spaces over the field of</span>
<span class="sd">      rationals</span>

<span class="sd">    See :mod:`sage.categories.primer` for an introduction to</span>
<span class="sd">    categories in Sage, their relevance, purpose, and usage. The</span>
<span class="sd">    documentation below will focus on their implementation.</span>

<span class="sd">    Technically, a category is an instance of the class</span>
<span class="sd">    :class:`Category` or some of its subclasses. Some categories, like</span>
<span class="sd">    :class:`VectorSpaces`, are parametrized: ``VectorSpaces(QQ)`` is one of</span>
<span class="sd">    many instances of the class :class:`VectorSpaces`. On the other</span>
<span class="sd">    hand, ``EuclideanDomains()`` is the single instance of the class</span>
<span class="sd">    :class:`EuclideanDomains`.</span>

<span class="sd">    Recall that an algebraic structure (say, the ring `\QQ[x]`) is</span>
<span class="sd">    modelled in Sage by an object which is called a parent. This</span>
<span class="sd">    object belongs to certain categories (here ``EuclideanDomains()`` and</span>
<span class="sd">    ``Algebras()``). The elements of the ring are themselves objects.</span>

<span class="sd">    The class of a category (say :class:`EuclideanDomains`) can define simultaneously:</span>

<span class="sd">    - Operations on the category itself (what is its super categories?</span>
<span class="sd">      its category of morphisms? its dual category?).</span>
<span class="sd">    - Generic operations on parents in this category, like the ring `\QQ[x]`.</span>
<span class="sd">    - Generic operations on elements of such parents (e. g., the</span>
<span class="sd">      Euclidean algorithm for computing gcds).</span>
<span class="sd">    - Generic operations on morphisms of this category.</span>

<span class="sd">    This is achieved as follows::</span>

<span class="sd">        sage: from sage.categories.all import Category</span>
<span class="sd">        sage: class EuclideanDomains(Category):</span>
<span class="sd">        ....:     # operations on the category itself</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         [Rings()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     def dummy(self): # TODO: find some good examples</span>
<span class="sd">        ....:          pass</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods: # holds the generic operations on parents</span>
<span class="sd">        ....:          # TODO: find a good example of an operation</span>
<span class="sd">        ....:          pass</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ElementMethods:# holds the generic operations on elements</span>
<span class="sd">        ....:          def gcd(x,y):</span>
<span class="sd">        ....:              # Euclid algorithms</span>
<span class="sd">        ....:              pass</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class MorphismMethods: # holds the generic operations on morphisms</span>
<span class="sd">        ....:          # TODO: find a good example of an operation</span>
<span class="sd">        ....:          pass</span>
<span class="sd">        ....:</span>

<span class="sd">    Note that the nested class ``ParentMethods`` is merely a container</span>
<span class="sd">    of operations, and does not inherit from anything. Instead, the</span>
<span class="sd">    hierarchy relation is defined once at the level of the categories,</span>
<span class="sd">    and the actual hierarchy of classes is built in parallel from all</span>
<span class="sd">    the ``ParentMethods`` nested classes, and stored in the attributes</span>
<span class="sd">    ``parent_class``. Then, a parent in a category ``C`` receives the</span>
<span class="sd">    appropriate operations from all the super categories by usual</span>
<span class="sd">    class inheritance from ``C.parent_class``.</span>

<span class="sd">    Similarly, two other hierarchies of classes, for elements and</span>
<span class="sd">    morphisms respectively, are built from all the ``ElementMethods``</span>
<span class="sd">    and ``MorphismMethods`` nested classes.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    We define a hierarchy of four categories ``As()``, ``Bs()``,</span>
<span class="sd">    ``Cs()``, ``Ds()`` with a diamond inheritance. Think for example:</span>

<span class="sd">    - ``As()``: the category of sets</span>
<span class="sd">    - ``Bs()``: the category of additive groups</span>
<span class="sd">    - ``Cs()``: the category of multiplicative monoids</span>
<span class="sd">    - ``Ds()``: the category of rings</span>

<span class="sd">    ::</span>

<span class="sd">        sage: from sage.categories.all import Category</span>
<span class="sd">        sage: from sage.misc.lazy_attribute import lazy_attribute</span>
<span class="sd">        sage: class As (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return []</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fA(self):</span>
<span class="sd">        ....:             return "A"</span>
<span class="sd">        ....:         f = fA</span>

<span class="sd">        sage: class Bs (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return [As()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fB(self):</span>
<span class="sd">        ....:             return "B"</span>

<span class="sd">        sage: class Cs (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return [As()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fC(self):</span>
<span class="sd">        ....:             return "C"</span>
<span class="sd">        ....:         f = fC</span>

<span class="sd">        sage: class Ds (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return [Bs(),Cs()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fD(self):</span>
<span class="sd">        ....:             return "D"</span>

<span class="sd">    Categories should always have unique representation; by :trac:`12215`,</span>
<span class="sd">    this means that it will be kept in cache, but only</span>
<span class="sd">    if there is still some strong reference to it.</span>

<span class="sd">    We check this before proceeding::</span>

<span class="sd">        sage: import gc</span>
<span class="sd">        sage: idAs = id(As())</span>
<span class="sd">        sage: _ = gc.collect()</span>
<span class="sd">        sage: n == id(As())</span>
<span class="sd">        False</span>
<span class="sd">        sage: a = As()</span>
<span class="sd">        sage: id(As()) == id(As())</span>
<span class="sd">        True</span>
<span class="sd">        sage: As().parent_class == As().parent_class</span>
<span class="sd">        True</span>

<span class="sd">    We construct a parent in the category ``Ds()`` (that, is an instance</span>
<span class="sd">    of ``Ds().parent_class``), and check that it has access to all the</span>
<span class="sd">    methods provided by all the categories, with the appropriate</span>
<span class="sd">    inheritance order::</span>

<span class="sd">        sage: D = Ds().parent_class()</span>
<span class="sd">        sage: [ D.fA(), D.fB(), D.fC(), D.fD() ]</span>
<span class="sd">        ['A', 'B', 'C', 'D']</span>
<span class="sd">        sage: D.f()</span>
<span class="sd">        'C'</span>

<span class="sd">    ::</span>

<span class="sd">        sage: C = Cs().parent_class()</span>
<span class="sd">        sage: [ C.fA(), C.fC() ]</span>
<span class="sd">        ['A', 'C']</span>
<span class="sd">        sage: C.f()</span>
<span class="sd">        'C'</span>

<span class="sd">    Here is the parallel hierarchy of classes which has been built</span>
<span class="sd">    automatically, together with the method resolution order (``.mro()``)::</span>

<span class="sd">        sage: As().parent_class</span>
<span class="sd">        &lt;class '__main__.As.parent_class'&gt;</span>
<span class="sd">        sage: As().parent_class.__bases__</span>
<span class="sd">        (&lt;... 'object'&gt;,)</span>
<span class="sd">        sage: As().parent_class.mro()</span>
<span class="sd">        [&lt;class '__main__.As.parent_class'&gt;, &lt;... 'object'&gt;]</span>

<span class="sd">    ::</span>

<span class="sd">        sage: Bs().parent_class</span>
<span class="sd">        &lt;class '__main__.Bs.parent_class'&gt;</span>
<span class="sd">        sage: Bs().parent_class.__bases__</span>
<span class="sd">        (&lt;class '__main__.As.parent_class'&gt;,)</span>
<span class="sd">        sage: Bs().parent_class.mro()</span>
<span class="sd">        [&lt;class '__main__.Bs.parent_class'&gt;, &lt;class '__main__.As.parent_class'&gt;, &lt;... 'object'&gt;]</span>

<span class="sd">    ::</span>

<span class="sd">        sage: Cs().parent_class</span>
<span class="sd">        &lt;class '__main__.Cs.parent_class'&gt;</span>
<span class="sd">        sage: Cs().parent_class.__bases__</span>
<span class="sd">        (&lt;class '__main__.As.parent_class'&gt;,)</span>
<span class="sd">        sage: Cs().parent_class.__mro__</span>
<span class="sd">        (&lt;class '__main__.Cs.parent_class'&gt;, &lt;class '__main__.As.parent_class'&gt;, &lt;... 'object'&gt;)</span>

<span class="sd">    ::</span>

<span class="sd">        sage: Ds().parent_class</span>
<span class="sd">        &lt;class '__main__.Ds.parent_class'&gt;</span>
<span class="sd">        sage: Ds().parent_class.__bases__</span>
<span class="sd">        (&lt;class '__main__.Cs.parent_class'&gt;, &lt;class '__main__.Bs.parent_class'&gt;)</span>
<span class="sd">        sage: Ds().parent_class.mro()</span>
<span class="sd">        [&lt;class '__main__.Ds.parent_class'&gt;, &lt;class '__main__.Cs.parent_class'&gt;, &lt;class '__main__.Bs.parent_class'&gt;, &lt;class '__main__.As.parent_class'&gt;, &lt;... 'object'&gt;]</span>

<span class="sd">    Note that two categories in the same class need not have the</span>
<span class="sd">    same ``super_categories``. For example, ``Algebras(QQ)`` has</span>
<span class="sd">    ``VectorSpaces(QQ)`` as super category, whereas ``Algebras(ZZ)``</span>
<span class="sd">    only has ``Modules(ZZ)`` as super category. In particular, the</span>
<span class="sd">    constructed parent class and element class will differ (inheriting,</span>
<span class="sd">    or not, methods specific for vector spaces)::</span>

<span class="sd">        sage: Algebras(QQ).parent_class is Algebras(ZZ).parent_class</span>
<span class="sd">        False</span>
<span class="sd">        sage: issubclass(Algebras(QQ).parent_class, VectorSpaces(QQ).parent_class)</span>
<span class="sd">        True</span>

<span class="sd">    On the other hand, identical hierarchies of classes are,</span>
<span class="sd">    preferably, built only once (e.g. for categories over a base ring)::</span>

<span class="sd">        sage: Algebras(GF(5)).parent_class is Algebras(GF(7)).parent_class</span>
<span class="sd">        True</span>
<span class="sd">        sage: F = FractionField(ZZ['t'])</span>
<span class="sd">        sage: Coalgebras(F).parent_class is Coalgebras(FractionField(F['x'])).parent_class</span>
<span class="sd">        True</span>

<span class="sd">    We now construct a parent in the usual way::</span>

<span class="sd">        sage: class myparent(Parent):</span>
<span class="sd">        ....:     def __init__(self):</span>
<span class="sd">        ....:         Parent.__init__(self, category=Ds())</span>
<span class="sd">        ....:     def g(self):</span>
<span class="sd">        ....:         return "myparent"</span>
<span class="sd">        ....:     class Element(object):</span>
<span class="sd">        ....:         pass</span>
<span class="sd">        sage: D = myparent()</span>
<span class="sd">        sage: D.__class__</span>
<span class="sd">        &lt;class '__main__.myparent_with_category'&gt;</span>
<span class="sd">        sage: D.__class__.__bases__</span>
<span class="sd">        (&lt;class '__main__.myparent'&gt;, &lt;class '__main__.Ds.parent_class'&gt;)</span>
<span class="sd">        sage: D.__class__.mro()</span>
<span class="sd">        [&lt;class '__main__.myparent_with_category'&gt;,</span>
<span class="sd">        &lt;class '__main__.myparent'&gt;,</span>
<span class="sd">        &lt;type 'sage.structure.parent.Parent'&gt;,</span>
<span class="sd">        &lt;type 'sage.structure.category_object.CategoryObject'&gt;,</span>
<span class="sd">        &lt;type 'sage.structure.sage_object.SageObject'&gt;,</span>
<span class="sd">        &lt;class '__main__.Ds.parent_class'&gt;,</span>
<span class="sd">        &lt;class '__main__.Cs.parent_class'&gt;,</span>
<span class="sd">        &lt;class '__main__.Bs.parent_class'&gt;,</span>
<span class="sd">        &lt;class '__main__.As.parent_class'&gt;,</span>
<span class="sd">        &lt;... 'object'&gt;]</span>
<span class="sd">        sage: D.fA()</span>
<span class="sd">        'A'</span>
<span class="sd">        sage: D.fB()</span>
<span class="sd">        'B'</span>
<span class="sd">        sage: D.fC()</span>
<span class="sd">        'C'</span>
<span class="sd">        sage: D.fD()</span>
<span class="sd">        'D'</span>
<span class="sd">        sage: D.f()</span>
<span class="sd">        'C'</span>
<span class="sd">        sage: D.g()</span>
<span class="sd">        'myparent'</span>

<span class="sd">    ::</span>

<span class="sd">        sage: D.element_class</span>
<span class="sd">        &lt;class '__main__.myparent_with_category.element_class'&gt;</span>
<span class="sd">        sage: D.element_class.mro()</span>
<span class="sd">        [&lt;class '__main__.myparent_with_category.element_class'&gt;,</span>
<span class="sd">        &lt;class ...__main__....Element...&gt;,</span>
<span class="sd">        &lt;class '__main__.Ds.element_class'&gt;,</span>
<span class="sd">        &lt;class '__main__.Cs.element_class'&gt;,</span>
<span class="sd">        &lt;class '__main__.Bs.element_class'&gt;,</span>
<span class="sd">        &lt;class '__main__.As.element_class'&gt;,</span>
<span class="sd">        &lt;... 'object'&gt;]</span>


<span class="sd">    TESTS::</span>

<span class="sd">        sage: import __main__</span>
<span class="sd">        sage: __main__.myparent = myparent</span>
<span class="sd">        sage: __main__.As = As</span>
<span class="sd">        sage: __main__.Bs = Bs</span>
<span class="sd">        sage: __main__.Cs = Cs</span>
<span class="sd">        sage: __main__.Ds = Ds</span>
<span class="sd">        sage: loads(dumps(Ds)) is Ds</span>
<span class="sd">        True</span>
<span class="sd">        sage: loads(dumps(Ds())) is Ds()</span>
<span class="sd">        True</span>
<span class="sd">        sage: loads(dumps(Ds().element_class)) is Ds().element_class</span>
<span class="sd">        True</span>

<span class="sd">    .. automethod:: Category._super_categories</span>
<span class="sd">    .. automethod:: Category._super_categories_for_classes</span>
<span class="sd">    .. automethod:: Category._all_super_categories</span>
<span class="sd">    .. automethod:: Category._all_super_categories_proper</span>
<span class="sd">    .. automethod:: Category._set_of_super_categories</span>
<span class="sd">    .. automethod:: Category._make_named_class</span>
<span class="sd">    .. automethod:: Category._repr_</span>
<span class="sd">    .. automethod:: Category._repr_object_names</span>
<span class="sd">    .. automethod:: Category._test_category</span>
<span class="sd">    .. automethod:: Category._with_axiom</span>
<span class="sd">    .. automethod:: Category._with_axiom_as_tuple</span>
<span class="sd">    .. automethod:: Category._without_axioms</span>
<span class="sd">    .. automethod:: Category._sort</span>
<span class="sd">    .. automethod:: Category._sort_uniq</span>
<span class="sd">    .. automethod:: Category.__classcall__</span>
<span class="sd">    .. automethod:: Category.__init__</span>
<span class="sd">    """</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Input mangling for unique representation.</span>

<span class="sd">        Let ``C = Cs(...)`` be a category. Since :trac:`12895`, the</span>
<span class="sd">        class of ``C`` is a dynamic subclass ``Cs_with_category`` of</span>
<span class="sd">        ``Cs`` in order for ``C`` to inherit code from the</span>
<span class="sd">        ``SubcategoryMethods`` nested classes of its super categories.</span>

<span class="sd">        The purpose of this ``__classcall__`` method is to ensure that</span>
<span class="sd">        reconstructing ``C`` from its class with</span>
<span class="sd">        ``Cs_with_category(...)`` actually calls properly ``Cs(...)``</span>
<span class="sd">        and gives back ``C``.</span>

<span class="sd">        .. SEEALSO:: :meth:`subcategory_class`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: A = Algebras(QQ)</span>
<span class="sd">            sage: A.__class__</span>
<span class="sd">            &lt;class 'sage.categories.algebras.Algebras_with_category'&gt;</span>
<span class="sd">            sage: A is Algebras(QQ)</span>
<span class="sd">            True</span>
<span class="sd">            sage: A is A.__class__(QQ)</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DynamicMetaclass</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__base__</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Category</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Initialize this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: class SemiprimitiveRings(Category):</span>
<span class="sd">            ....:     def super_categories(self):</span>
<span class="sd">            ....:         return [Rings()]</span>
<span class="sd">            ....:     class ParentMethods:</span>
<span class="sd">            ....:         def jacobson_radical(self):</span>
<span class="sd">            ....:             return self.ideal(0)</span>
<span class="sd">            sage: C = SemiprimitiveRings()</span>
<span class="sd">            sage: C</span>
<span class="sd">            Category of semiprimitive rings</span>
<span class="sd">            sage: C.__class__</span>
<span class="sd">            &lt;class '__main__.SemiprimitiveRings_with_category'&gt;</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Specifying the name of this category by passing a string</span>
<span class="sd">            is deprecated. If the default name (built from the name of</span>
<span class="sd">            the class) is not adequate, please use</span>
<span class="sd">            :meth:`_repr_object_names` to customize it.</span>
<span class="sd">        """</span>
        <span class="k">assert</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">dynamic_class</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2">_with_category"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcategory_class</span><span class="p">,</span> <span class="p">),</span>
                                       <span class="n">cache</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">reduction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="n">doccls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A short name of ``self``, obtained from its type.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._label</span>
<span class="sd">            'Rings'</span>

<span class="sd">        """</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[:</span><span class="n">t</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">"'"</span><span class="p">)]</span>

    <span class="c1"># TODO: move this code into the method _repr_object_names once passing a string is not accepted anymore</span>
    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">__repr_object_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Determine the name of the objects of this category</span>
<span class="sd">        from its type, if it has not been explicitly given</span>
<span class="sd">        at initialisation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._Category__repr_object_names</span>
<span class="sd">            'rings'</span>
<span class="sd">            sage: PrincipalIdealDomains()._Category__repr_object_names</span>
<span class="sd">            'principal ideal domains'</span>

<span class="sd">            sage: Rings()</span>
<span class="sd">            Category of rings</span>
<span class="sd">        """</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_object_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the name of the objects of this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: FiniteGroups()._repr_object_names()</span>
<span class="sd">            'finite groups'</span>
<span class="sd">            sage: AlgebrasWithBasis(QQ)._repr_object_names()</span>
<span class="sd">            'algebras with basis over Rational Field'</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__repr_object_names</span>

    <span class="k">def</span> <span class="nf">_short_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a CamelCase name for this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CoxeterGroups()._short_name()</span>
<span class="sd">            'CoxeterGroups'</span>

<span class="sd">            sage: AlgebrasWithBasis(QQ)._short_name()</span>
<span class="sd">            'AlgebrasWithBasis'</span>

<span class="sd">        Conventions for short names should be discussed at the level</span>
<span class="sd">        of Sage, and only then applied accordingly here.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">an_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return an instance of this class.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings.an_instance()</span>
<span class="sd">            Category of rings</span>

<span class="sd">        Parametrized categories should overload this default</span>
<span class="sd">        implementation to provide appropriate arguments::</span>

<span class="sd">            sage: Algebras.an_instance()</span>
<span class="sd">            Category of algebras over Rational Field</span>
<span class="sd">            sage: Bimodules.an_instance()</span>
<span class="sd">            Category of bimodules over Rational Field on the left and Real Field with 53 bits of precision on the right</span>
<span class="sd">            sage: AlgebraIdeals.an_instance()</span>
<span class="sd">            Category of algebra ideals in Univariate Polynomial Ring in x over Rational Field</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construct an object in this category from the data in ``x``,</span>
<span class="sd">        or throw ``TypeError`` or ``NotImplementedError``.</span>

<span class="sd">        If ``x`` is readily in ``self`` it is returned unchanged.</span>
<span class="sd">        Categories wishing to extend this minimal behavior should</span>
<span class="sd">        implement :meth:`._call_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()(ZZ)</span>
<span class="sd">            Integer Ring</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construct an object in this category from the data in ``x``,</span>
<span class="sd">        or throw ``NotImplementedError``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Semigroups()._call_(3)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the print representation of this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets() # indirect doctest</span>
<span class="sd">            Category of sets</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="s2">"Category of </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Returns the latex representation of this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: latex(Sets()) # indirect doctest</span>
<span class="sd">            \mathbf{Sets}</span>
<span class="sd">            sage: latex(CommutativeAdditiveSemigroups())</span>
<span class="sd">            \mathbf{CommutativeAdditiveSemigroups}</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">mathbf{</span><span class="si">%s</span><span class="s2">}"</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_short_name</span><span class="p">()</span>

<span class="c1">#   The convention for which hash function to use should be decided at the level of UniqueRepresentation</span>
<span class="c1">#   The implementation below is bad (hash independent of the base ring)</span>
<span class="c1">#     def __hash__(self):</span>
<span class="c1">#         """</span>
<span class="c1">#         Returns a hash for this category.</span>
<span class="c1">#</span>
<span class="c1">#         Currently this is just the hash of the string representing the category.</span>
<span class="c1">#</span>
<span class="c1">#         EXAMPLES::</span>
<span class="c1">#</span>
<span class="c1">#             sage: hash(Algebras(QQ)) #indirect doctest</span>
<span class="c1">#             699942203</span>
<span class="c1">#             sage: hash(Algebras(ZZ))</span>
<span class="c1">#             699942203</span>
<span class="c1">#         """</span>
<span class="c1">#         return hash(self.__category) # Any reason not to use id?</span>

    <span class="k">def</span> <span class="nf">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Quick subcategory check.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``category`` -- a category</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - ``True``, if ``category`` is a subcategory of ``self``.</span>
<span class="sd">        - ``False``, if ``category`` is not a subcategory of ``self``.</span>
<span class="sd">        - ``Unknown``, if a quick check was not enough to determine</span>
<span class="sd">          whether ``category`` is a subcategory of ``self`` or not.</span>

<span class="sd">        The aim of this method is to offer a framework to add cheap</span>
<span class="sd">        tests for subcategories. When doing</span>
<span class="sd">        ``category.is_subcategory(self)`` (note the reverse order of</span>
<span class="sd">        ``self`` and ``category``), this method is usually called</span>
<span class="sd">        first.  Only if it returns ``Unknown``, :meth:`is_subcategory`</span>
<span class="sd">        will build the list of super categories of ``category``.</span>

<span class="sd">        This method need not to handle the case where ``category`` is</span>
<span class="sd">        ``self``; this is the first test that is done in</span>
<span class="sd">        :meth:`is_subcategory`.</span>

<span class="sd">        This default implementation tests whether the parent class of</span>
<span class="sd">        ``category`` is a subclass of the parent class of ``self``.</span>
<span class="sd">        This is most of the time a complete subcategory test.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            This test is incomplete for categories in</span>
<span class="sd">            :class:`CategoryWithParameters`, as introduced by</span>
<span class="sd">            :trac:`11935`. This method is therefore overwritten by</span>
<span class="sd">            :meth:`~sage.categories.category.CategoryWithParameters._subcategory_hook_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._subcategory_hook_(Rings())</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">category</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Membership testing</span>

<span class="sd">        Returns whether ``x`` is an object in this category, that is</span>
<span class="sd">        if the category of ``x`` is a subcategory of ``self``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: ZZ in Sets()</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__classcontains__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Membership testing, without arguments</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``cls`` -- a category class</span>
<span class="sd">        - ``x`` -- any object</span>

<span class="sd">        Returns whether ``x`` is an object of a category which is an instance</span>
<span class="sd">        of ``cls``.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        This method makes it easy to test if an object is, say, a</span>
<span class="sd">        vector space, without having to specify the base ring::</span>

<span class="sd">            sage: F = FreeModule(QQ,3)</span>
<span class="sd">            sage: F in VectorSpaces</span>
<span class="sd">            True</span>

<span class="sd">            sage: F = FreeModule(ZZ,3)</span>
<span class="sd">            sage: F in VectorSpaces</span>
<span class="sd">            False</span>

<span class="sd">            sage: F in Algebras</span>
<span class="sd">            False</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Non category objects shall be handled properly::</span>

<span class="sd">            sage: [1,2] in Algebras</span>
<span class="sd">            False</span>
<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">categories</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_abelian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return whether this category is abelian.</span>

<span class="sd">        An abelian category is a category satisfying:</span>

<span class="sd">        - It has a zero object;</span>
<span class="sd">        - It has all pullbacks and pushouts;</span>
<span class="sd">        - All monomorphisms and epimorphisms are normal.</span>

<span class="sd">        Equivalently, one can define an increasing sequence of conditions:</span>

<span class="sd">        - A category is pre-additive if it is enriched over abelian groups</span>
<span class="sd">          (all homsets are abelian groups and composition is bilinear);</span>
<span class="sd">        - A pre-additive category is additive if every finite set of objects</span>
<span class="sd">          has a biproduct (we can form direct sums and direct products);</span>
<span class="sd">        - An additive category is pre-abelian if every morphism has both a</span>
<span class="sd">          kernel and a cokernel;</span>
<span class="sd">        - A pre-abelian category is abelian if every monomorphism is the</span>
<span class="sd">          kernel of some morphism and every epimorphism is the cokernel of</span>
<span class="sd">          some morphism.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Modules(ZZ).is_abelian()</span>
<span class="sd">            True</span>
<span class="sd">            sage: FreeModules(ZZ).is_abelian()</span>
<span class="sd">            False</span>
<span class="sd">            sage: FreeModules(QQ).is_abelian()</span>
<span class="sd">            True</span>
<span class="sd">            sage: CommutativeAdditiveGroups().is_abelian()</span>
<span class="sd">            True</span>
<span class="sd">            sage: Semigroups().is_abelian()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: is_abelian</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"is_abelian"</span><span class="p">)</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Methods related to the category hierarchy</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">category_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Returns the graph of all super categories of this category</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ)</span>
<span class="sd">            sage: G = C.category_graph()</span>
<span class="sd">            sage: G.is_directed_acyclic()</span>
<span class="sd">            True</span>

<span class="sd">        The girth of a directed acyclic graph is infinite, however,</span>
<span class="sd">        the girth of the underlying undirected graph is 4 in this case::</span>

<span class="sd">            sage: Graph(G).girth()</span>
<span class="sd">            4</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">category_graph</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>

    <span class="nd">@abstract_method</span>
    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the *immediate* super categories of ``self``.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a duplicate-free list of categories.</span>

<span class="sd">        Every category should implement this method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Groups().super_categories()</span>
<span class="sd">            [Category of monoids, Category of inverse unital magmas]</span>
<span class="sd">            sage: Objects().super_categories()</span>
<span class="sd">            []</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Since :trac:`10963`, the order of the categories in the</span>
<span class="sd">            result is irrelevant. For details, see</span>
<span class="sd">            :ref:`category-primer-category-order`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Whenever speed matters, developers are advised to use the</span>
<span class="sd">            lazy attribute :meth:`_super_categories` instead of</span>
<span class="sd">            calling this method.</span>
<span class="sd">        """</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_all_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        All the super categories of this category, including this category.</span>

<span class="sd">        Since :trac:`11943`, the order of super categories is</span>
<span class="sd">        determined by Python's method resolution order C3 algorithm.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_super_categories`</span>

<span class="sd">        .. note:: this attribute is likely to eventually become a tuple.</span>

<span class="sd">        .. note:: this sets :meth:`_super_categories_for_classes` as a side effect</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Rings(); C</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: C._all_super_categories</span>
<span class="sd">            [Category of rings, Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>
<span class="sd">        """</span>
        <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span> <span class="o">=</span> <span class="n">C3_sorted_merge</span><span class="p">([</span><span class="n">cat</span><span class="o">.</span><span class="n">_all_super_categories</span>
                                           <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">]</span> <span class="o">+</span>
                                          <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">],</span>
                                          <span class="n">category_sort_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">category_sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">"Inconsistent sorting results for all super categories of </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories_for_classes</span> <span class="o">=</span> <span class="n">bases</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_all_super_categories_proper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        All the proper super categories of this category.</span>

<span class="sd">        Since :trac:`11943`, the order of super categories is</span>
<span class="sd">        determined by Python's method resolution order C3 algorithm.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_super_categories`</span>

<span class="sd">        .. note:: this attribute is likely to eventually become a tuple.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Rings(); C</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: C._all_super_categories_proper</span>
<span class="sd">            [Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_set_of_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The frozen set of all proper super categories of this category.</span>

<span class="sd">        .. note:: this is used for speeding up category containment tests.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_super_categories`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: sorted(Groups()._set_of_super_categories, key=str)</span>
<span class="sd">            [Category of inverse unital magmas,</span>
<span class="sd">             Category of magmas,</span>
<span class="sd">             Category of monoids,</span>
<span class="sd">             Category of objects,</span>
<span class="sd">             Category of semigroups,</span>
<span class="sd">             Category of sets,</span>
<span class="sd">             Category of sets with partial maps,</span>
<span class="sd">             Category of unital magmas]</span>
<span class="sd">            sage: sorted(Groups()._set_of_super_categories, key=str)</span>
<span class="sd">            [Category of inverse unital magmas, Category of magmas, Category of monoids,</span>
<span class="sd">             Category of objects, Category of semigroups, Category of sets,</span>
<span class="sd">             Category of sets with partial maps, Category of unital magmas]</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: C = HopfAlgebrasWithBasis(GF(7))</span>
<span class="sd">            sage: C._set_of_super_categories == frozenset(C._all_super_categories_proper)</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories_proper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">all_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the list of all super categories of this category.</span>

<span class="sd">        INPUT:</span>

<span class="sd">         - ``proper`` -- a boolean (default: ``False``); whether to exclude this category.</span>

<span class="sd">        Since :trac:`11943`, the order of super categories is</span>
<span class="sd">        determined by Python's method resolution order C3 algorithm.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Whenever speed matters, the developers are advised to use</span>
<span class="sd">            instead the lazy attributes :meth:`_all_super_categories`,</span>
<span class="sd">            :meth:`_all_super_categories_proper`, or</span>
<span class="sd">            :meth:`_set_of_super_categories`, as</span>
<span class="sd">            appropriate. Simply because lazy attributes are much</span>
<span class="sd">            faster than any method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Rings(); C</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: C.all_super_categories()</span>
<span class="sd">            [Category of rings, Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>

<span class="sd">            sage: C.all_super_categories(proper = True)</span>
<span class="sd">            [Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>

<span class="sd">            sage: Sets().all_super_categories()</span>
<span class="sd">            [Category of sets, Category of sets with partial maps, Category of objects]</span>
<span class="sd">            sage: Sets().all_super_categories(proper=True)</span>
<span class="sd">            [Category of sets with partial maps, Category of objects]</span>
<span class="sd">            sage: Sets().all_super_categories() is Sets()._all_super_categories</span>
<span class="sd">            True</span>
<span class="sd">            sage: Sets().all_super_categories(proper=True) is Sets()._all_super_categories_proper</span>
<span class="sd">            True</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">proper</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories_proper</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The immediate super categories of this category.</span>

<span class="sd">        This lazy attribute caches the result of the mandatory method</span>
<span class="sd">        :meth:`super_categories` for speed. It also does some mangling</span>
<span class="sd">        (flattening join categories, sorting, ...).</span>

<span class="sd">        Whenever speed matters, developers are advised to use this</span>
<span class="sd">        lazy attribute rather than calling :meth:`super_categories`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This attribute is likely to eventually become a tuple.</span>
<span class="sd">            When this happens, we might as well use :meth:`Category._sort`,</span>
<span class="sd">            if not :meth:`Category._sort_uniq`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._super_categories</span>
<span class="sd">            [Category of rngs, Category of semirings]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_flatten_categories</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">(),</span><span class="n">JoinCategory</span><span class="p">),</span> <span class="n">key</span> <span class="o">=</span> <span class="n">category_sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_super_categories_for_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The super categories of this category used for building classes.</span>

<span class="sd">        This is a close variant of :meth:`_super_categories` used for</span>
<span class="sd">        constructing the list of the bases for :meth:`parent_class`,</span>
<span class="sd">        :meth:`element_class`, and friends. The purpose is ensure that</span>
<span class="sd">        Python will find a proper Method Resolution Order for those</span>
<span class="sd">        classes. For background, see :mod:`sage.misc.c3_controlled`.</span>

<span class="sd">        .. SEEALSO:: :meth:`_cmp_key`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This attribute is calculated as a by-product of computing</span>
<span class="sd">            :meth:`_all_super_categories`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._super_categories_for_classes</span>
<span class="sd">            [Category of rngs, Category of semirings]</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories_for_classes</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Methods handling of full subcategories</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">additional_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return whether ``self`` defines additional structure.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - ``self`` if ``self`` defines additional structure and</span>
<span class="sd">          ``None`` otherwise. This default implementation returns</span>
<span class="sd">          ``self``.</span>

<span class="sd">        A category `C` *defines additional structure* if `C`-morphisms</span>
<span class="sd">        shall preserve more structure (e.g. operations) than that</span>
<span class="sd">        specified by the super categories of `C`. For example, the</span>
<span class="sd">        category of magmas defines additional structure, namely the</span>
<span class="sd">        operation `*` that shall be preserved by magma morphisms. On</span>
<span class="sd">        the other hand the category of rings does not define additional</span>
<span class="sd">        structure: a function between two rings that is both a unital</span>
<span class="sd">        magma morphism and a unital additive magma morphism is</span>
<span class="sd">        automatically a ring morphism.</span>

<span class="sd">        Formally speaking `C` *defines additional structure*, if `C`</span>
<span class="sd">        is *not* a full subcategory of the join of its super</span>
<span class="sd">        categories: the morphisms need to preserve more structure, and</span>
<span class="sd">        thus the homsets are smaller.</span>

<span class="sd">        By default, a category is considered as defining additional</span>
<span class="sd">        structure, unless it is a :ref:`category with axiom</span>
<span class="sd">        &lt;category-primer-axioms&gt;`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Here are some typical structure categories, with the</span>
<span class="sd">        additional structure they define::</span>

<span class="sd">            sage: Sets().additional_structure()</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Magmas().additional_structure()         # `*`</span>
<span class="sd">            Category of magmas</span>
<span class="sd">            sage: AdditiveMagmas().additional_structure() # `+`</span>
<span class="sd">            Category of additive magmas</span>
<span class="sd">            sage: LeftModules(ZZ).additional_structure()  # left multiplication by scalar</span>
<span class="sd">            Category of left modules over Integer Ring</span>
<span class="sd">            sage: Coalgebras(QQ).additional_structure()   # coproduct</span>
<span class="sd">            Category of coalgebras over Rational Field</span>
<span class="sd">            sage: Crystals().additional_structure()       # crystal operators</span>
<span class="sd">            Category of crystals</span>

<span class="sd">        On the other hand, the category of semigroups is not a</span>
<span class="sd">        structure category, since its operation `+` is already defined</span>
<span class="sd">        by the category of magmas::</span>

<span class="sd">            sage: Semigroups().additional_structure()</span>

<span class="sd">        Most :ref:`categories with axiom &lt;category-primer-axioms&gt;`</span>
<span class="sd">        don't define additional structure::</span>

<span class="sd">            sage: Sets().Finite().additional_structure()</span>
<span class="sd">            sage: Rings().Commutative().additional_structure()</span>
<span class="sd">            sage: Modules(QQ).FiniteDimensional().additional_structure()</span>
<span class="sd">            sage: from sage.categories.magmatic_algebras import MagmaticAlgebras</span>
<span class="sd">            sage: MagmaticAlgebras(QQ).Unital().additional_structure()</span>

<span class="sd">        As of Sage 6.4, the only exceptions are the category of unital</span>
<span class="sd">        magmas or the category of unital additive magmas (both define</span>
<span class="sd">        a unit which shall be preserved by morphisms)::</span>

<span class="sd">            sage: Magmas().Unital().additional_structure()</span>
<span class="sd">            Category of unital magmas</span>
<span class="sd">            sage: AdditiveMagmas().AdditiveUnital().additional_structure()</span>
<span class="sd">            Category of additive unital additive magmas</span>

<span class="sd">        Similarly, :ref:`functorial construction categories</span>
<span class="sd">        &lt;category-primer-functorial-constructions&gt;` don't define</span>
<span class="sd">        additional structure, unless the construction is actually</span>
<span class="sd">        defined by their base category. For example, the category of</span>
<span class="sd">        graded modules defines a grading which shall be preserved by</span>
<span class="sd">        morphisms::</span>

<span class="sd">            sage: Modules(ZZ).Graded().additional_structure()</span>
<span class="sd">            Category of graded modules over Integer Ring</span>

<span class="sd">        On the other hand, the category of graded algebras does not</span>
<span class="sd">        define additional structure; indeed an algebra morphism which</span>
<span class="sd">        is also a module morphism is a graded algebra morphism::</span>

<span class="sd">            sage: Algebras(ZZ).Graded().additional_structure()</span>

<span class="sd">        Similarly, morphisms are requested to preserve the structure</span>
<span class="sd">        given by the following constructions::</span>

<span class="sd">            sage: Sets().Quotients().additional_structure()</span>
<span class="sd">            Category of quotients of sets</span>
<span class="sd">            sage: Sets().CartesianProducts().additional_structure()</span>
<span class="sd">            Category of Cartesian products of sets</span>
<span class="sd">            sage: Modules(QQ).TensorProducts().additional_structure()</span>

<span class="sd">        This might change, as we are lacking enough data points to</span>
<span class="sd">        guarantee that this was the correct design decision.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            In some cases a category defines additional structure,</span>
<span class="sd">            where the structure can be useful to manipulate morphisms</span>
<span class="sd">            but where, in most use cases, we don't want the morphisms</span>
<span class="sd">            to necessarily preserve it. For example, in the context of</span>
<span class="sd">            finite dimensional vector spaces, having a distinguished</span>
<span class="sd">            basis allows for representing morphisms by matrices; yet</span>
<span class="sd">            considering only morphisms that preserve that</span>
<span class="sd">            distinguished basis would be boring.</span>

<span class="sd">            In such cases, we might want to eventually have two</span>
<span class="sd">            categories, one where the additional structure is</span>
<span class="sd">            preserved, and one where it's not necessarily preserved</span>
<span class="sd">            (we would need to find an idiom for this).</span>

<span class="sd">            At this point, a choice is to be made each time, according</span>
<span class="sd">            to the main use cases. Some of those choices are yet to be</span>
<span class="sd">            settled. For example, should by default:</span>

<span class="sd">            - an euclidean domain morphism preserve euclidean</span>
<span class="sd">              division? ::</span>

<span class="sd">                  sage: EuclideanDomains().additional_structure()</span>
<span class="sd">                  Category of euclidean domains</span>

<span class="sd">            - an enumerated set morphism preserve the distinguished</span>
<span class="sd">              enumeration? ::</span>

<span class="sd">                  sage: EnumeratedSets().additional_structure()</span>

<span class="sd">            - a module with basis morphism preserve the distinguished</span>
<span class="sd">              basis? ::</span>

<span class="sd">                  sage: Modules(QQ).WithBasis().additional_structure()</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            This method together with the methods overloading it</span>
<span class="sd">            provide the basic data to determine, for a given category,</span>
<span class="sd">            the super categories that define some structure (see</span>
<span class="sd">            :meth:`structure`), and to test whether a category is a</span>
<span class="sd">            full subcategory of some other category (see</span>
<span class="sd">            :meth:`is_full_subcategory`). For example, the category of</span>
<span class="sd">            Coxeter groups is not full subcategory of the category of</span>
<span class="sd">            groups since morphisms need to preserve the distinguished</span>
<span class="sd">            generators::</span>

<span class="sd">                sage: CoxeterGroups().is_full_subcategory(Groups())</span>
<span class="sd">                False</span>

<span class="sd">            The support for modeling full subcategories has been</span>
<span class="sd">            introduced in :trac:`16340`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return the structure ``self`` is endowed with.</span>

<span class="sd">        This method returns the structure that morphisms in this</span>
<span class="sd">        category shall be preserving. For example, it tells that a</span>
<span class="sd">        ring is a set endowed with a structure of both a unital magma</span>
<span class="sd">        and an additive unital magma which satisfies some further</span>
<span class="sd">        axioms. In other words, a ring morphism is a function that</span>
<span class="sd">        preserves the unital magma and additive unital magma</span>
<span class="sd">        structure.</span>

<span class="sd">        In practice, this returns the collection of all the super</span>
<span class="sd">        categories of ``self`` that define some additional structure,</span>
<span class="sd">        as a frozen set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Objects().structure()</span>
<span class="sd">            frozenset()</span>

<span class="sd">            sage: def structure(C):</span>
<span class="sd">            ....:     return Category._sort(C.structure())</span>

<span class="sd">            sage: structure(Sets())</span>
<span class="sd">            (Category of sets, Category of sets with partial maps)</span>
<span class="sd">            sage: structure(Magmas())</span>
<span class="sd">            (Category of magmas, Category of sets, Category of sets with partial maps)</span>

<span class="sd">        In the following example, we only list the smallest structure</span>
<span class="sd">        categories to get a more readable output::</span>

<span class="sd">            sage: def structure(C):</span>
<span class="sd">            ....:     return Category._sort_uniq(C.structure())</span>

<span class="sd">            sage: structure(Magmas())</span>
<span class="sd">            (Category of magmas,)</span>
<span class="sd">            sage: structure(Rings())</span>
<span class="sd">            (Category of unital magmas, Category of additive unital additive magmas)</span>
<span class="sd">            sage: structure(Fields())</span>
<span class="sd">            (Category of euclidean domains,)</span>
<span class="sd">            sage: structure(Algebras(QQ))</span>
<span class="sd">            (Category of unital magmas,</span>
<span class="sd">             Category of right modules over Rational Field,</span>
<span class="sd">             Category of left modules over Rational Field)</span>
<span class="sd">            sage: structure(HopfAlgebras(QQ).Graded().WithBasis().Connected())</span>
<span class="sd">            (Category of hopf algebras over Rational Field,</span>
<span class="sd">             Category of graded modules over Rational Field)</span>

<span class="sd">        This method is used in :meth:`is_full_subcategory` for</span>
<span class="sd">        deciding whether a category is a full subcategory of some</span>
<span class="sd">        other category, and for documentation purposes. It is computed</span>
<span class="sd">        recursively from the result of :meth:`additional_structure`</span>
<span class="sd">        on the super categories of ``self``.</span>
<span class="sd">        """</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span> <span class="n">D</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span> <span class="k">for</span> <span class="n">D</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">structure</span><span class="p">()</span> <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_full_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return whether ``self`` is a full subcategory of ``other``.</span>

<span class="sd">        A subcategory `B` of a category `A` is a *full subcategory* if</span>
<span class="sd">        any `A`-morphism between two objects of `B` is also a</span>
<span class="sd">        `B`-morphism (the reciprocal always holds: any `B`-morphism</span>
<span class="sd">        between two objects of `B` is an `A`-morphism).</span>

<span class="sd">        This is computed by testing whether ``self`` is a subcategory</span>
<span class="sd">        of ``other`` and whether they have the same structure, as</span>
<span class="sd">        determined by :meth:`structure` from the</span>
<span class="sd">        result of :meth:`additional_structure` on the super</span>
<span class="sd">        categories.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            A positive answer is guaranteed to be mathematically</span>
<span class="sd">            correct. A negative answer may mean that Sage has not been</span>
<span class="sd">            taught enough information (or can not yet within the</span>
<span class="sd">            current model) to derive this information. See</span>
<span class="sd">            :meth:`full_super_categories` for a discussion.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`is_subcategory`</span>
<span class="sd">            - :meth:`full_super_categories`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Magmas().Associative().is_full_subcategory(Magmas())</span>
<span class="sd">            True</span>
<span class="sd">            sage: Magmas().Unital().is_full_subcategory(Magmas())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Rings().is_full_subcategory(Magmas().Unital() &amp; AdditiveMagmas().AdditiveUnital())</span>
<span class="sd">            True</span>

<span class="sd">        Here are two typical examples of false negatives::</span>

<span class="sd">            sage: Groups().is_full_subcategory(Semigroups())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Groups().is_full_subcategory(Semigroups()) # todo: not implemented</span>
<span class="sd">            True</span>
<span class="sd">            sage: Fields().is_full_subcategory(Rings())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Fields().is_full_subcategory(Rings())      # todo: not implemented</span>
<span class="sd">            True</span>

<span class="sd">        .. TODO::</span>

<span class="sd">            The latter is a consequence of :class:`EuclideanDomains`</span>
<span class="sd">            currently being a structure category. Is this what we</span>
<span class="sd">            want? ::</span>

<span class="sd">                sage: EuclideanDomains().is_full_subcategory(Rings())</span>
<span class="sd">                False</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">())</span> <span class="o">==</span> \
           <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">structure</span><span class="p">())</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">full_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return the *immediate* full super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`super_categories`</span>
<span class="sd">            - :meth:`is_full_subcategory`</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            The current implementation selects the full subcategories</span>
<span class="sd">            among the immediate super categories of ``self``. This</span>
<span class="sd">            assumes that, if `C\subset B\subset A` is a chain of</span>
<span class="sd">            categories and `C` is a full subcategory of `A`, then `C`</span>
<span class="sd">            is a full subcategory of `B` and `B` is a full subcategory</span>
<span class="sd">            of `A`.</span>

<span class="sd">            This assumption is guaranteed to hold with the current</span>
<span class="sd">            model and implementation of full subcategories in</span>
<span class="sd">            Sage. However, mathematically speaking, this is too</span>
<span class="sd">            restrictive. This indeed prevents the complete modelling</span>
<span class="sd">            of situations where any `A` morphism between elements of</span>
<span class="sd">            `C` automatically preserves the `B` structure. See below</span>
<span class="sd">            for an example.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A semigroup morphism between two finite semigroups is a finite</span>
<span class="sd">        semigroup morphism::</span>

<span class="sd">            sage: Semigroups().Finite().full_super_categories()</span>
<span class="sd">            [Category of semigroups]</span>

<span class="sd">        On the other hand, a semigroup morphism between two monoids is</span>
<span class="sd">        not necessarily a monoid morphism (which must map the unit to</span>
<span class="sd">        the unit)::</span>

<span class="sd">            sage: Monoids().super_categories()</span>
<span class="sd">            [Category of semigroups, Category of unital magmas]</span>
<span class="sd">            sage: Monoids().full_super_categories()</span>
<span class="sd">            [Category of unital magmas]</span>

<span class="sd">        Any semigroup morphism between two groups is automatically a</span>
<span class="sd">        monoid morphism (in a group the unit is the unique idempotent,</span>
<span class="sd">        so it has to be mapped to the unit). Yet, due to the</span>
<span class="sd">        limitation of the model advertised above, Sage currently cannot</span>
<span class="sd">        be taught that the category of groups is a full subcategory of</span>
<span class="sd">        the category of semigroups::</span>

<span class="sd">            sage: Groups().full_super_categories()     # todo: not implemented</span>
<span class="sd">            [Category of monoids, Category of semigroups, Category of inverse unital magmas]</span>
<span class="sd">            sage: Groups().full_super_categories()</span>
<span class="sd">            [Category of monoids, Category of inverse unital magmas]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">C</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">C</span><span class="p">)]</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Test methods</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">_test_category_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Check that the category graph matches with Python's method resolution order</span>

<span class="sd">        .. note::</span>

<span class="sd">            By :trac:`11943`, the list of categories returned by</span>
<span class="sd">            :meth:`all_super_categories` is supposed to match with the</span>
<span class="sd">            method resolution order of the parent and element</span>
<span class="sd">            classes. This method checks this.</span>

<span class="sd">        .. todo:: currently, this won't work for hom categories.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = HopfAlgebrasWithBasis(QQ)</span>
<span class="sd">            sage: C.parent_class.mro() == [X.parent_class for X in C._all_super_categories] + [object]</span>
<span class="sd">            True</span>
<span class="sd">            sage: C.element_class.mro() == [X.element_class for X in C._all_super_categories] + [object]</span>
<span class="sd">            True</span>
<span class="sd">            sage: TestSuite(C).run()    # indirect doctest</span>

<span class="sd">        """</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="n">mro</span><span class="p">(),</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">parent_class</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">object</span><span class="p">])</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">mro</span><span class="p">(),</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">element_class</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">object</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_test_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Run generic tests on this category</span>

<span class="sd">        .. SEEALSO:: :class:`TestSuite`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._test_category()</span>

<span class="sd">        Let us now write a couple broken categories::</span>

<span class="sd">            sage: class MyObjects(Category):</span>
<span class="sd">            ....:      pass</span>
<span class="sd">            sage: MyObjects()._test_category()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: &lt;abstract method super_categories at ...&gt;</span>

<span class="sd">            sage: class MyObjects(Category):</span>
<span class="sd">            ....:      def super_categories(self):</span>
<span class="sd">            ....:          return tuple()</span>
<span class="sd">            sage: MyObjects()._test_category()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AssertionError: Category of my objects.super_categories() should return a list</span>

<span class="sd">            sage: class MyObjects(Category):</span>
<span class="sd">            ....:      def super_categories(self):</span>
<span class="sd">            ....:          return []</span>
<span class="sd">            sage: MyObjects()._test_category()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AssertionError: Category of my objects is not a subcategory of Objects()</span>

<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">sage.categories.objects</span>    <span class="k">import</span> <span class="n">Objects</span>
        <span class="kn">from</span> <span class="nn">sage.categories.sets_cat</span> <span class="k">import</span> <span class="n">Sets</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">(),</span> <span class="nb">list</span><span class="p">),</span>
                       <span class="s2">"</span><span class="si">%s</span><span class="s2">.super_categories() should return a list"</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Objects</span><span class="p">()),</span>
                       <span class="s2">"</span><span class="si">%s</span><span class="s2"> is not a subcategory of Objects()"</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">):</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmp_key</span> <span class="o">&gt;</span> <span class="n">cat</span><span class="o">.</span><span class="n">_cmp_key</span>      <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">))</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">())</span> <span class="p">))</span> <span class="c1"># Not an obviously passing test with axioms</span>

        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories_proper</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">category</span><span class="p">):</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_super_categories</span><span class="p">()),</span>
                               <span class="s2">"Every full super category should be a super category"</span>
                               <span class="s2">"of some immediate full super category"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Sets</span><span class="p">()):</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

    <span class="n">_cmp_key</span> <span class="o">=</span> <span class="n">_cmp_key</span>


    <span class="c1">##########################################################################</span>
    <span class="c1"># Construction of the associated abstract classes for parents, elements, ...</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">_make_named_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">picklable</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construction of the parent/element/... class of ``self``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``name`` -- a string; the name of the class as an attribute of</span>
<span class="sd">          ``self``. E.g. "parent_class"</span>
<span class="sd">        - ``method_provider`` -- a string; the name of an attribute of</span>
<span class="sd">          ``self`` that provides methods for the new class (in</span>
<span class="sd">          addition to those coming from the super categories).</span>
<span class="sd">          E.g. "ParentMethods"</span>
<span class="sd">        - ``cache`` -- a boolean or ``ignore_reduction`` (default: ``False``)</span>
<span class="sd">          (passed down to dynamic_class; for internal use only)</span>
<span class="sd">        - ``picklable`` -- a boolean (default: ``True``)</span>

<span class="sd">        ASSUMPTION:</span>

<span class="sd">        It is assumed that this method is only called from a lazy</span>
<span class="sd">        attribute whose name coincides with the given ``name``.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A dynamic class with bases given by the corresponding named</span>
<span class="sd">        classes of ``self``'s super_categories, and methods taken from</span>
<span class="sd">        the class ``getattr(self,method_provider)``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            - In this default implementation, the reduction data of</span>
<span class="sd">              the named class makes it depend on ``self``. Since the</span>
<span class="sd">              result is going to be stored in a lazy attribute of</span>
<span class="sd">              ``self`` anyway, we may as well disable the caching in</span>
<span class="sd">              ``dynamic_class`` (hence the default value</span>
<span class="sd">              ``cache=False``).</span>

<span class="sd">            - :class:`CategoryWithParameters` overrides this method so</span>
<span class="sd">              that the same parent/element/... classes can be shared</span>
<span class="sd">              between closely related categories.</span>

<span class="sd">            - The bases of the named class may also contain the named</span>
<span class="sd">              classes of some indirect super categories, according to</span>
<span class="sd">              :meth:`_super_categories_for_classes`. This is to</span>
<span class="sd">              guarantee that Python will build consistent method</span>
<span class="sd">              resolution orders. For background, see</span>
<span class="sd">              :mod:`sage.misc.c3_controlled`.</span>

<span class="sd">        .. SEEALSO:: :meth:`CategoryWithParameters._make_named_class`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: PC = Rings()._make_named_class("parent_class", "ParentMethods"); PC</span>
<span class="sd">            &lt;class 'sage.categories.rings.Rings.parent_class'&gt;</span>
<span class="sd">            sage: type(PC)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>
<span class="sd">            sage: PC.__bases__</span>
<span class="sd">            (&lt;class 'sage.categories.rngs.Rngs.parent_class'&gt;,</span>
<span class="sd">             &lt;class 'sage.categories.semirings.Semirings.parent_class'&gt;)</span>

<span class="sd">        Note that, by default, the result is not cached::</span>

<span class="sd">            sage: PC is Rings()._make_named_class("parent_class", "ParentMethods")</span>
<span class="sd">            False</span>

<span class="sd">        Indeed this method is only meant to construct lazy attributes</span>
<span class="sd">        like ``parent_class`` which already handle this caching::</span>

<span class="sd">            sage: Rings().parent_class</span>
<span class="sd">            &lt;class 'sage.categories.rings.Rings.parent_class'&gt;</span>

<span class="sd">        Reduction for pickling also assumes the existence of this lazy</span>
<span class="sd">        attribute::</span>

<span class="sd">            sage: PC._reduction</span>
<span class="sd">            (&lt;built-in function getattr&gt;, (Category of rings, 'parent_class'))</span>
<span class="sd">            sage: loads(dumps(PC)) is Rings().parent_class</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: class A: pass</span>
<span class="sd">            sage: class BrokenCategory(Category):</span>
<span class="sd">            ....:     def super_categories(self): return []</span>
<span class="sd">            ....:     ParentMethods = 1</span>
<span class="sd">            ....:     class ElementMethods(A):</span>
<span class="sd">            ....:         pass</span>
<span class="sd">            ....:     class MorphismMethods(object):</span>
<span class="sd">            ....:         pass</span>
<span class="sd">            sage: C = BrokenCategory()</span>
<span class="sd">            sage: C._make_named_class("parent_class",   "ParentMethods")</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AssertionError: BrokenCategory.ParentMethods should be a class</span>
<span class="sd">            sage: C._make_named_class("element_class",  "ElementMethods")</span>
<span class="sd">            doctest:...: UserWarning: BrokenCategory.ElementMethods should not have a super class</span>
<span class="sd">            &lt;class '__main__.BrokenCategory.element_class'&gt;</span>
<span class="sd">            sage: C._make_named_class("morphism_class", "MorphismMethods")</span>
<span class="sd">            &lt;class '__main__.BrokenCategory.morphism_class'&gt;</span>
<span class="sd">        """</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DynamicMetaclass</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__base__</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">"</span><span class="o">%</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">method_provider_cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method_provider_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the category provides no XXXMethods class,</span>
            <span class="c1"># point to the documentation of the category itself</span>
            <span class="n">doccls</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, check XXXMethods</span>
            <span class="k">assert</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">method_provider_cls</span><span class="p">),</span>\
                <span class="s2">"</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> should be a class"</span><span class="o">%</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">)</span>
            <span class="n">mro</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmro</span><span class="p">(</span><span class="n">method_provider_cls</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mro</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mro</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">mro</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">object</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> should not have a super class"</span><span class="o">%</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">))</span>
            <span class="c1"># and point the documentation to it</span>
            <span class="n">doccls</span> <span class="o">=</span> <span class="n">method_provider_cls</span>
        <span class="k">if</span> <span class="n">picklable</span><span class="p">:</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">dynamic_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span>
                             <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories_for_classes</span><span class="p">),</span>
                             <span class="n">method_provider_cls</span><span class="p">,</span> <span class="n">prepend_cls_bases</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">doccls</span> <span class="o">=</span> <span class="n">doccls</span><span class="p">,</span>
                             <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">)</span>


    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">subcategory_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A common superclass for all subcategories of this category (including this one).</span>

<span class="sd">        This class derives from ``D.subcategory_class`` for each super</span>
<span class="sd">        category `D` of ``self``, and includes all the methods from</span>
<span class="sd">        the nested class ``self.SubcategoryMethods``, if it exists.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :trac:`12895`</span>
<span class="sd">            - :meth:`parent_class`</span>
<span class="sd">            - :meth:`element_class`</span>
<span class="sd">            - :meth:`_make_named_class`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cls = Rings().subcategory_class; cls</span>
<span class="sd">            &lt;class 'sage.categories.rings.Rings.subcategory_class'&gt;</span>
<span class="sd">            sage: type(cls)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>

<span class="sd">        ``Rings()`` is an instance of this class, as well as all its subcategories::</span>

<span class="sd">            sage: isinstance(Rings(), cls)</span>
<span class="sd">            True</span>
<span class="sd">            sage: isinstance(AlgebrasWithBasis(QQ), cls)</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: cls = Algebras(QQ).subcategory_class; cls</span>
<span class="sd">            &lt;class 'sage.categories.algebras.Algebras.subcategory_class'&gt;</span>
<span class="sd">            sage: type(cls)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">'subcategory_class'</span><span class="p">,</span> <span class="s1">'SubcategoryMethods'</span><span class="p">,</span>
                                      <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">picklable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">parent_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        A common super class for all parents in this category (and its</span>
<span class="sd">        subcategories).</span>

<span class="sd">        This class contains the methods defined in the nested class</span>
<span class="sd">        ``self.ParentMethods`` (if it exists), and has as bases the</span>
<span class="sd">        parent classes of the super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`element_class`, :meth:`morphism_class`</span>
<span class="sd">            - :class:`Category` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ).parent_class; C</span>
<span class="sd">            &lt;class 'sage.categories.algebras.Algebras.parent_class'&gt;</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>

<span class="sd">        By :trac:`11935`, some categories share their parent</span>
<span class="sd">        classes. For example, the parent class of an algebra only</span>
<span class="sd">        depends on the category of the base ring. A typical example is</span>
<span class="sd">        the category of algebras over a finite field versus algebras</span>
<span class="sd">        over a non-field::</span>

<span class="sd">            sage: Algebras(GF(7)).parent_class is Algebras(GF(5)).parent_class</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ).parent_class is Algebras(ZZ).parent_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Algebras(ZZ['t']).parent_class is Algebras(ZZ['t','x']).parent_class</span>
<span class="sd">            True</span>

<span class="sd">        See :class:`CategoryWithParameters` for an abstract base class for</span>
<span class="sd">        categories that depend on parameters, even though the parent</span>
<span class="sd">        and element classes only depend on the parent or element</span>
<span class="sd">        classes of its super categories. It is used in</span>
<span class="sd">        :class:`~sage.categories.bimodules.Bimodules`,</span>
<span class="sd">        :class:`~sage.categories.category_types.Category_over_base` and</span>
<span class="sd">        :class:`sage.categories.category.JoinCategory`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">'parent_class'</span><span class="p">,</span> <span class="s1">'ParentMethods'</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        A common super class for all elements of parents in this category</span>
<span class="sd">        (and its subcategories).</span>

<span class="sd">        This class contains the methods defined in the nested class</span>
<span class="sd">        ``self.ElementMethods`` (if it exists), and has as bases the</span>
<span class="sd">        element classes of the super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`parent_class`, :meth:`morphism_class`</span>
<span class="sd">            - :class:`Category` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ).element_class; C</span>
<span class="sd">            &lt;class 'sage.categories.algebras.Algebras.element_class'&gt;</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>

<span class="sd">        By :trac:`11935`, some categories share their element</span>
<span class="sd">        classes. For example, the element class of an algebra only</span>
<span class="sd">        depends on the category of the base. A typical example is the</span>
<span class="sd">        category of algebras over a field versus algebras over a</span>
<span class="sd">        non-field::</span>

<span class="sd">            sage: Algebras(GF(5)).element_class is Algebras(GF(3)).element_class</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ).element_class is Algebras(ZZ).element_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Algebras(ZZ['t']).element_class is Algebras(ZZ['t','x']).element_class</span>
<span class="sd">            True</span>

<span class="sd">        These classes are constructed with ``__slots__ = ()``, so</span>
<span class="sd">        instances may not have a ``__dict__``::</span>

<span class="sd">            sage: E = FiniteEnumeratedSets().element_class</span>
<span class="sd">            sage: E.__dictoffset__</span>
<span class="sd">            0</span>

<span class="sd">        .. SEEALSO:: :meth:`parent_class`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">'element_class'</span><span class="p">,</span> <span class="s1">'ElementMethods'</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">morphism_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        A common super class for all morphisms between parents in this</span>
<span class="sd">        category (and its subcategories).</span>

<span class="sd">        This class contains the methods defined in the nested class</span>
<span class="sd">        ``self.MorphismMethods`` (if it exists), and has as bases the</span>
<span class="sd">        morphism classes of the super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`parent_class`, :meth:`element_class`</span>
<span class="sd">            - :class:`Category` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ).morphism_class; C</span>
<span class="sd">            &lt;class 'sage.categories.algebras.Algebras.morphism_class'&gt;</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">'morphism_class'</span><span class="p">,</span> <span class="s1">'MorphismMethods'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">required_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the methods that are required and optional for parents</span>
<span class="sd">        in this category and their elements.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Algebras(QQ).required_methods() # py2</span>
<span class="sd">            {'element': {'optional': ['_add_', '_mul_'], 'required': ['__nonzero__']},</span>
<span class="sd">             'parent': {'optional': ['algebra_generators'], 'required': ['__contains__']}}</span>
<span class="sd">            sage: Algebras(QQ).required_methods() # py3</span>
<span class="sd">            {'element': {'optional': ['_add_', '_mul_'], 'required': ['__bool__']},</span>
<span class="sd">             'parent': {'optional': ['algebra_generators'], 'required': ['__contains__']}}</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">{</span> <span class="s2">"parent"</span>  <span class="p">:</span> <span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">),</span>
                 <span class="s2">"element"</span> <span class="p">:</span> <span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span> <span class="p">}</span>


    <span class="c1"># Operations on the lattice of categories</span>
    <span class="k">def</span> <span class="nf">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns True if self is naturally embedded as a subcategory of c.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: AbGrps = CommutativeAdditiveGroups()</span>
<span class="sd">            sage: Rings().is_subcategory(AbGrps)</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbGrps.is_subcategory(Rings())</span>
<span class="sd">            False</span>

<span class="sd">        The ``is_subcategory`` function takes into account the</span>
<span class="sd">        base.</span>

<span class="sd">        ::</span>

<span class="sd">            sage: M3 = VectorSpaces(FiniteField(3))</span>
<span class="sd">            sage: M9 = VectorSpaces(FiniteField(9, 'a'))</span>
<span class="sd">            sage: M3.is_subcategory(M9)</span>
<span class="sd">            False</span>

<span class="sd">        Join categories are properly handled::</span>

<span class="sd">            sage: CatJ = Category.join((CommutativeAdditiveGroups(), Semigroups()))</span>
<span class="sd">            sage: Rings().is_subcategory(CatJ)</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: V3 = VectorSpaces(FiniteField(3))</span>
<span class="sd">            sage: POSet = PartiallyOrderedSets()</span>
<span class="sd">            sage: PoV3 = Category.join((V3, POSet))</span>
<span class="sd">            sage: A3 = AlgebrasWithBasis(FiniteField(3))</span>
<span class="sd">            sage: PoA3 = Category.join((A3, POSet))</span>
<span class="sd">            sage: PoA3.is_subcategory(PoV3)</span>
<span class="sd">            True</span>
<span class="sd">            sage: PoV3.is_subcategory(PoV3)</span>
<span class="sd">            True</span>
<span class="sd">            sage: PoV3.is_subcategory(PoA3)</span>
<span class="sd">            False</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">subcat_hook</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subcat_hook</span> <span class="ow">is</span> <span class="n">Unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_of_super_categories</span>
        <span class="k">return</span> <span class="n">subcat_hook</span>

    <span class="k">def</span> <span class="nf">or_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">join</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return ``category`` or ``self`` if ``category`` is ``None``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``category`` -- a sub category of ``self``, tuple/list thereof,</span>
<span class="sd">          or ``None``</span>
<span class="sd">        - ``join`` -- a boolean (default: ``False``)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a category</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Monoids().or_subcategory(Groups())</span>
<span class="sd">            Category of groups</span>
<span class="sd">            sage: Monoids().or_subcategory(None)</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        If category is a list/tuple, then a join category is returned::</span>

<span class="sd">            sage: Monoids().or_subcategory((CommutativeAdditiveMonoids(), Groups()))</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>

<span class="sd">        If ``join`` is ``False``, an error if raised if category is not a</span>
<span class="sd">        subcategory of ``self``::</span>

<span class="sd">            sage: Monoids().or_subcategory(EnumeratedSets())</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: Subcategory of `Category of monoids` required; got `Category of enumerated sets`</span>

<span class="sd">        Otherwise, the two categories are joined together::</span>

<span class="sd">            sage: Monoids().or_subcategory(EnumeratedSets(), join=True)</span>
<span class="sd">            Category of enumerated monoids</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">category</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Subcategory of `</span><span class="si">{}</span><span class="s2">` required; got `</span><span class="si">{}</span><span class="s2">`"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">category</span>

    <span class="k">def</span> <span class="nf">_is_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Same as is_subcategory, but c may also be the class of a</span>
<span class="sd">        category instead of a category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Fields()._is_subclass(Rings)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ)._is_subclass(Modules)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ)._is_subclass(ModulesWithBasis)</span>
<span class="sd">            False</span>
<span class="sd">        """</span>
        <span class="k">assert</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Category</span><span class="p">))</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Category</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">)</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_meet_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the largest common subcategory of self and other:</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Monoids()._meet_(Monoids())</span>
<span class="sd">            Category of monoids</span>
<span class="sd">            sage: Rings()._meet_(Rings())</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: Rings()._meet_(Monoids())</span>
<span class="sd">            Category of monoids</span>
<span class="sd">            sage: Monoids()._meet_(Rings())</span>
<span class="sd">            Category of monoids</span>

<span class="sd">            sage: VectorSpaces(QQ)._meet_(Modules(ZZ))</span>
<span class="sd">            Category of commutative additive groups</span>
<span class="sd">            sage: Algebras(ZZ)._meet_(Algebras(QQ))</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: Groups()._meet_(Rings())</span>
<span class="sd">            Category of monoids</span>
<span class="sd">            sage: Algebras(QQ)._meet_(Category.join([Fields(), ModulesWithBasis(QQ)]))</span>
<span class="sd">            Join of Category of rings and Category of vector spaces over Rational Field</span>

<span class="sd">        Note: abstractly, the category poset is a distributive</span>
<span class="sd">        lattice, so this is well defined; however, the subset of those</span>
<span class="sd">        categories actually implemented is not: we need to also</span>
<span class="sd">        include their join-categories.</span>

<span class="sd">        For example, the category of rings is *not* the join of the</span>
<span class="sd">        category of abelian groups and that of semi groups, just a</span>
<span class="sd">        subcategory of their join, since rings further require</span>
<span class="sd">        distributivity.</span>

<span class="sd">        For the meet computation, there may be several lowest common</span>
<span class="sd">        sub categories of self and other, in which case, we need to</span>
<span class="sd">        take the join of them all.</span>

<span class="sd">        FIXME:</span>

<span class="sd">        - If A is a subcategory of B, A has *more* structure than B,</span>
<span class="sd">          but then *less* objects in there. We should choose an</span>
<span class="sd">          appropriate convention for A&lt;B. Using subcategory calls</span>
<span class="sd">          for A&lt;B, but the current meet and join call for A&gt;B.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span> <span class="c1"># useful? fast pathway</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Useful fast pathway; try:</span>
            <span class="c1"># %time L = EllipticCurve('960d1').prove_BSD()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meet_</span><span class="p">(</span><span class="n">sup</span><span class="p">)</span> <span class="k">for</span> <span class="n">sup</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">meet</span><span class="p">(</span><span class="n">categories</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the meet of a list of categories</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``categories`` - a non empty list (or iterable) of categories</span>

<span class="sd">        .. SEEALSO:: :meth:`__or__` for a shortcut</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category.meet([Algebras(ZZ), Algebras(QQ), Groups()])</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        That meet of an empty list should be a category which is a</span>
<span class="sd">        subcategory of all categories, which does not make practical sense::</span>

<span class="sd">            sage: Category.meet([])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: The meet of an empty list of categories is not implemented</span>
<span class="sd">        """</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">categories</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The meet of an empty list of categories is not implemented"</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">categories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_meet_</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the axioms known to be satisfied by all the objects of ``self``.</span>

<span class="sd">        Technically, this is the set of all the axioms ``A`` such that, if</span>
<span class="sd">        ``Cs`` is the category defining ``A``, then ``self`` is a subcategory</span>
<span class="sd">        of ``Cs().A()``. Any additional axiom ``A`` would yield a strict</span>
<span class="sd">        subcategory of ``self``, at the very least ``self &amp; Cs().A()`` where</span>
<span class="sd">        ``Cs`` is the category defining ``A``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Monoids().axioms()</span>
<span class="sd">            frozenset({'Associative', 'Unital'})</span>
<span class="sd">            sage: (EnumeratedSets().Infinite() &amp; Sets().Facade()).axioms()</span>
<span class="sd">            frozenset({'Enumerated', 'Facade', 'Infinite'})</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">axiom</span>
                         <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span>
                         <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="n">category</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_with_axiom_as_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a tuple of categories whose join is ``self._with_axiom()``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``axiom`` -- a string, the name of an axiom</span>

<span class="sd">        This is a lazy version of :meth:`_with_axiom` which is used to</span>
<span class="sd">        avoid recursion loops during join calculations.</span>

<span class="sd">        .. NOTE:: The order in the result is irrelevant.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._with_axiom_as_tuple('Finite')</span>
<span class="sd">            (Category of finite sets,)</span>
<span class="sd">            sage: Magmas()._with_axiom_as_tuple('Finite')</span>
<span class="sd">            (Category of magmas, Category of finite sets)</span>
<span class="sd">            sage: Rings().Division()._with_axiom_as_tuple('Finite')</span>
<span class="sd">            (Category of division rings,</span>
<span class="sd">             Category of finite monoids,</span>
<span class="sd">             Category of commutative magmas,</span>
<span class="sd">             Category of finite additive groups)</span>
<span class="sd">            sage: HopfAlgebras(QQ)._with_axiom_as_tuple('FiniteDimensional')</span>
<span class="sd">            (Category of hopf algebras over Rational Field,</span>
<span class="sd">             Category of finite dimensional modules over Rational Field)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">axiom_attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axiom_attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the axiom is not defined for this category, ignore it</span>
            <span class="c1"># This uses the following invariant: the categories for</span>
            <span class="c1"># which a given axiom is defined form a lower set</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="c1"># self implements this axiom</span>
            <span class="kn">from</span> <span class="nn">.category_with_axiom</span> <span class="k">import</span> <span class="n">CategoryWithAxiom</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">axiom_attribute</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">axiom_attribute</span><span class="p">,</span> <span class="n">CategoryWithAxiom</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">axiom_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>
            <span class="n">warn</span><span class="p">((</span><span class="s2">"Expecting </span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2"> to be a subclass of CategoryWithAxiom to"</span>
                  <span class="s2">" implement a category with axiom; got </span><span class="si">{}</span><span class="s2">; ignoring"</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="n">axiom_attribute</span><span class="p">))</span>

        <span class="c1"># self does not implement this axiom</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> \
                 <span class="nb">tuple</span><span class="p">(</span><span class="n">cat</span>
                       <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span>
                       <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">category</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="n">axiom</span><span class="p">))</span>
        <span class="n">hook</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="o">+</span><span class="s2">"_extra_super_categories"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">hook</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hook</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">_sort_uniq</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_with_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the subcategory of the objects of ``self`` satisfying</span>
<span class="sd">        the given ``axiom``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``axiom`` -- a string, the name of an axiom</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._with_axiom("Finite")</span>
<span class="sd">            Category of finite sets</span>

<span class="sd">            sage: type(Magmas().Finite().Commutative())</span>
<span class="sd">            &lt;class 'sage.categories.category.JoinCategory_with_category'&gt;</span>
<span class="sd">            sage: Magmas().Finite().Commutative().super_categories()</span>
<span class="sd">            [Category of commutative magmas, Category of finite sets]</span>
<span class="sd">            sage: Algebras(QQ).WithBasis().Commutative() is Algebras(QQ).Commutative().WithBasis()</span>
<span class="sd">            True</span>

<span class="sd">        When ``axiom`` is not defined for ``self``, ``self`` is returned::</span>

<span class="sd">            sage: Sets()._with_axiom("Associative")</span>
<span class="sd">            Category of sets</span>

<span class="sd">        .. WARNING:: This may be changed in the future to raising an error.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="n">axiom</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_with_axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axioms</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the subcategory of the objects of ``self`` satisfying</span>
<span class="sd">        the given ``axioms``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``axioms`` -- a list of strings, the names of the axioms</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._with_axioms(["Finite"])</span>
<span class="sd">            Category of finite sets</span>
<span class="sd">            sage: Sets()._with_axioms(["Infinite"])</span>
<span class="sd">            Category of infinite sets</span>
<span class="sd">            sage: FiniteSets()._with_axioms(["Finite"])</span>
<span class="sd">            Category of finite sets</span>

<span class="sd">        Axioms that are not defined for the ``self`` are ignored::</span>

<span class="sd">            sage: Sets()._with_axioms(["FooBar"])</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Magmas()._with_axioms(["FooBar", "Unital"])</span>
<span class="sd">            Category of unital magmas</span>

<span class="sd">        Note that adding several axioms at once can do more than</span>
<span class="sd">        adding them one by one. This is because the availability of an</span>
<span class="sd">        axiom may depend on another axiom. For example, for</span>
<span class="sd">        semigroups, the ``Inverse`` axiom is meaningless unless there</span>
<span class="sd">        is a unit::</span>

<span class="sd">            sage: Semigroups().Inverse()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AttributeError: 'Semigroups_with_category' object has no attribute 'Inverse'</span>
<span class="sd">            sage: Semigroups()._with_axioms(["Inverse"])</span>
<span class="sd">            Category of semigroups</span>

<span class="sd">        So one needs to first add the ``Unital`` axiom, and then the</span>
<span class="sd">        ``Inverse`` axiom::</span>

<span class="sd">            sage: Semigroups().Unital().Inverse()</span>
<span class="sd">            Category of groups</span>

<span class="sd">        or to specify all of them at once, in any order::</span>

<span class="sd">            sage: Semigroups()._with_axioms(["Inverse", "Unital"])</span>
<span class="sd">            Category of groups</span>
<span class="sd">            sage: Semigroups()._with_axioms(["Unital", "Inverse"])</span>
<span class="sd">            Category of groups</span>

<span class="sd">            sage: Magmas()._with_axioms(['Commutative', 'Associative', 'Unital','Inverse'])</span>
<span class="sd">            Category of commutative groups</span>
<span class="sd">            sage: Magmas()._with_axioms(['Inverse', 'Commutative', 'Associative', 'Unital'])</span>
<span class="sd">            Category of commutative groups</span>
<span class="sd">        """</span>
        <span class="c1"># We repeat adding axioms until they have all been</span>
        <span class="c1"># integrated or nothing happens</span>
        <span class="n">axioms</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">axioms</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">previous</span><span class="p">:</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="n">axioms</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span>
            <span class="n">axioms</span> <span class="o">=</span> <span class="n">axioms</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_without_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return the category with axiom ``axiom`` removed.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A category ``C`` which does not have axiom ``axiom``</span>
<span class="sd">        and such that either ``C`` is ``self``, or adding back all the</span>
<span class="sd">        axioms of ``self`` gives back ``self``.</span>

<span class="sd">        .. WARNING:: This is not guaranteed to be robust.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._without_axiom("Facade")</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Sets().Facade()._without_axiom("Facade")</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Algebras(QQ)._without_axiom("Unital")</span>
<span class="sd">            Category of associative algebras over Rational Field</span>
<span class="sd">            sage: Groups()._without_axiom("Unital") # todo: not implemented</span>
<span class="sd">            Category of semigroups</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">axiom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot remove axiom </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axiom</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_without_axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return the category without the axioms that have been added</span>
<span class="sd">        to create it.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``named`` -- a boolean (default: ``False``)</span>

<span class="sd">        .. TODO:: Improve this explanation.</span>

<span class="sd">        If ``named`` is ``True``, then this stops at the first</span>
<span class="sd">        category that has an explicit name of its own. See</span>
<span class="sd">        :meth:`.category_with_axiom.CategoryWithAxiom._without_axioms`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._without_axioms()</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Semigroups()._without_axioms()</span>
<span class="sd">            Category of magmas</span>
<span class="sd">            sage: Algebras(QQ).Commutative().WithBasis()._without_axioms()</span>
<span class="sd">            Category of magmatic algebras over Rational Field</span>
<span class="sd">            sage: Algebras(QQ).Commutative().WithBasis()._without_axioms(named=True)</span>
<span class="sd">            Category of algebras over Rational Field</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_flatten_categories</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_flatten_categories</span><span class="p">)</span>  <span class="c1"># a cythonised helper</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort</span><span class="p">(</span><span class="n">categories</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the categories after sorting them decreasingly according</span>
<span class="sd">        to their comparison key.</span>

<span class="sd">        .. SEEALSO:: :meth:`_cmp_key`</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``categories`` -- a list (or iterable) of non-join categories</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A sorted tuple of categories, possibly with repeats.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The auxiliary function `_flatten_categories` used in the test</span>
<span class="sd">            below expects a second argument, which is a type such that</span>
<span class="sd">            instances of that type will be replaced by its super</span>
<span class="sd">            categories. Usually, this type is :class:`JoinCategory`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category._sort([Sets(), Objects(), Coalgebras(QQ), Monoids(), Sets().Finite()])</span>
<span class="sd">            (Category of monoids,</span>
<span class="sd">             Category of coalgebras over Rational Field,</span>
<span class="sd">             Category of finite sets,</span>
<span class="sd">             Category of sets,</span>
<span class="sd">             Category of objects)</span>
<span class="sd">            sage: Category._sort([Sets().Finite(), Semigroups().Finite(), Sets().Facade(),Magmas().Commutative()])</span>
<span class="sd">            (Category of finite semigroups,</span>
<span class="sd">             Category of commutative magmas,</span>
<span class="sd">             Category of finite sets,</span>
<span class="sd">             Category of facade sets)</span>
<span class="sd">            sage: Category._sort(Category._flatten_categories([Sets().Finite(), Algebras(QQ).WithBasis(), Semigroups().Finite(), Sets().Facade(),Algebras(QQ).Commutative(), Algebras(QQ).Graded().WithBasis()], sage.categories.category.JoinCategory))</span>
<span class="sd">            (Category of algebras with basis over Rational Field,</span>
<span class="sd">             Category of algebras with basis over Rational Field,</span>
<span class="sd">             Category of graded algebras over Rational Field,</span>
<span class="sd">             Category of commutative algebras over Rational Field,</span>
<span class="sd">             Category of finite semigroups,</span>
<span class="sd">             Category of finite sets,</span>
<span class="sd">             Category of facade sets)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">category_sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="n">_sort_uniq</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_sort_uniq</span><span class="p">)</span>  <span class="c1"># a cythonised helper</span>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the intersection of two categories.</span>

<span class="sd">        This is just a shortcut for :meth:`join`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets().Finite() &amp; Rings().Commutative()</span>
<span class="sd">            Category of finite commutative rings</span>
<span class="sd">            sage: Monoids() &amp; CommutativeAdditiveMonoids()</span>
<span class="sd">            Join of Category of monoids and Category of commutative additive monoids</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the smallest category containing the two categories.</span>

<span class="sd">        This is just a shortcut for :meth:`meet`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Algebras(QQ) | Groups()</span>
<span class="sd">            Category of monoids</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">meet</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="n">_join_cache</span> <span class="o">=</span> <span class="n">_join_cache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_axioms</span><span class="o">=</span><span class="p">(),</span> <span class="n">axioms</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the join of the input categories in the lattice of categories.</span>

<span class="sd">        At the level of objects and morphisms, this operation</span>
<span class="sd">        corresponds to intersection: the objects and morphisms of a</span>
<span class="sd">        join category are those that belong to all its super</span>
<span class="sd">        categories.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``categories`` -- a list (or iterable) of categories</span>
<span class="sd">        - ``as_list`` -- a boolean (default: ``False``);</span>
<span class="sd">          whether the result should be returned as a list</span>
<span class="sd">        - ``axioms`` -- a tuple of strings; the names of some</span>
<span class="sd">          supplementary axioms</span>

<span class="sd">        .. SEEALSO:: :meth:`__and__` for a shortcut</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: J = Category.join((Groups(), CommutativeAdditiveMonoids())); J</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>
<span class="sd">            sage: J.super_categories()</span>
<span class="sd">            [Category of groups, Category of commutative additive monoids]</span>
<span class="sd">            sage: J.all_super_categories(proper=True)</span>
<span class="sd">            [Category of groups, ..., Category of magmas,</span>
<span class="sd">             Category of commutative additive monoids, ..., Category of additive magmas,</span>
<span class="sd">             Category of sets, ...]</span>

<span class="sd">        As a short hand, one can use::</span>

<span class="sd">            sage: Groups() &amp; CommutativeAdditiveMonoids()</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>

<span class="sd">        This is a commutative and associative operation::</span>

<span class="sd">            sage: Groups() &amp; Posets()</span>
<span class="sd">            Join of Category of groups and Category of posets</span>
<span class="sd">            sage: Posets() &amp; Groups()</span>
<span class="sd">            Join of Category of groups and Category of posets</span>

<span class="sd">            sage: Groups() &amp; (CommutativeAdditiveMonoids() &amp; Posets())</span>
<span class="sd">            Join of Category of groups</span>
<span class="sd">                and Category of commutative additive monoids</span>
<span class="sd">                and Category of posets</span>
<span class="sd">            sage: (Groups() &amp; CommutativeAdditiveMonoids()) &amp; Posets()</span>
<span class="sd">            Join of Category of groups</span>
<span class="sd">                and Category of commutative additive monoids</span>
<span class="sd">                and Category of posets</span>

<span class="sd">        The join of a single category is the category itself::</span>

<span class="sd">            sage: Category.join([Monoids()])</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        Similarly, the join of several mutually comparable categories is</span>
<span class="sd">        the smallest one::</span>

<span class="sd">            sage: Category.join((Sets(), Rings(), Monoids()))</span>
<span class="sd">            Category of rings</span>

<span class="sd">        In particular, the unit is the top category :class:`Objects`::</span>

<span class="sd">            sage: Groups() &amp; Objects()</span>
<span class="sd">            Category of groups</span>

<span class="sd">        If the optional parameter ``as_list`` is ``True``, this</span>
<span class="sd">        returns the super categories of the join as a list, without</span>
<span class="sd">        constructing the join category itself::</span>

<span class="sd">            sage: Category.join((Groups(), CommutativeAdditiveMonoids()), as_list=True)</span>
<span class="sd">            [Category of groups, Category of commutative additive monoids]</span>
<span class="sd">            sage: Category.join((Sets(), Rings(), Monoids()), as_list=True)</span>
<span class="sd">            [Category of rings]</span>
<span class="sd">            sage: Category.join((Modules(ZZ), FiniteFields()), as_list=True)</span>
<span class="sd">            [Category of finite enumerated fields, Category of modules over Integer Ring]</span>
<span class="sd">            sage: Category.join([], as_list=True)</span>
<span class="sd">            []</span>
<span class="sd">            sage: Category.join([Groups()], as_list=True)</span>
<span class="sd">            [Category of groups]</span>
<span class="sd">            sage: Category.join([Groups() &amp; Posets()], as_list=True)</span>
<span class="sd">            [Category of groups, Category of posets]</span>

<span class="sd">        Support for axiom categories (TODO: put here meaningfull examples)::</span>

<span class="sd">            sage: Sets().Facade() &amp; Sets().Infinite()</span>
<span class="sd">            Category of facade infinite sets</span>
<span class="sd">            sage: Magmas().Infinite() &amp; Sets().Facade()</span>
<span class="sd">            Category of facade infinite magmas</span>

<span class="sd">            sage: FiniteSets() &amp; Monoids()</span>
<span class="sd">            Category of finite monoids</span>
<span class="sd">            sage: Rings().Commutative() &amp; Sets().Finite()</span>
<span class="sd">            Category of finite commutative rings</span>

<span class="sd">        Note that several of the above examples are actually join</span>
<span class="sd">        categories; they are just nicely displayed::</span>

<span class="sd">            sage: AlgebrasWithBasis(QQ) &amp; FiniteSets().Algebras(QQ)</span>
<span class="sd">            Join of Category of finite dimensional algebras with basis over Rational Field</span>
<span class="sd">                and Category of finite set algebras over Rational Field</span>

<span class="sd">            sage: UniqueFactorizationDomains() &amp; Algebras(QQ)</span>
<span class="sd">            Join of Category of unique factorization domains</span>
<span class="sd">                and Category of commutative algebras over Rational Field</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: Magmas().Unital().Commutative().Finite() is Magmas().Finite().Commutative().Unital()</span>
<span class="sd">            True</span>
<span class="sd">            sage: from sage.categories.category_with_axiom import TestObjects</span>
<span class="sd">            sage: T = TestObjects()</span>
<span class="sd">            sage: TCF = T.Commutative().Facade(); TCF</span>
<span class="sd">            Category of facade commutative test objects</span>
<span class="sd">            sage: TCF is T.Facade().Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF is (T.Facade() &amp; T.Commutative())</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF.axioms()</span>
<span class="sd">            frozenset({'Commutative', 'Facade'})</span>
<span class="sd">            sage: type(TCF)</span>
<span class="sd">            &lt;class 'sage.categories.category_with_axiom.TestObjects.Commutative.Facade_with_category'&gt;</span>

<span class="sd">            sage: TCF = T.Commutative().FiniteDimensional()</span>
<span class="sd">            sage: TCF is T.FiniteDimensional().Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF is T.Commutative() &amp; T.FiniteDimensional()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF is T.FiniteDimensional() &amp; T.Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: type(TCF)</span>
<span class="sd">            &lt;class 'sage.categories.category_with_axiom.TestObjects.Commutative.FiniteDimensional_with_category'&gt;</span>

<span class="sd">            sage: TCU = T.Commutative().Unital()</span>
<span class="sd">            sage: TCU is T.Unital().Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCU is T.Commutative() &amp; T.Unital()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCU is T.Unital() &amp; T.Commutative()</span>
<span class="sd">            True</span>

<span class="sd">            sage: TUCF = T.Unital().Commutative().FiniteDimensional(); TUCF</span>
<span class="sd">            Category of finite dimensional commutative unital test objects</span>
<span class="sd">            sage: type(TUCF)</span>
<span class="sd">            &lt;class 'sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital.Commutative_with_category'&gt;</span>

<span class="sd">            sage: TFFC = T.Facade().FiniteDimensional().Commutative(); TFFC</span>
<span class="sd">            Category of facade finite dimensional commutative test objects</span>
<span class="sd">            sage: type(TFFC)</span>
<span class="sd">            &lt;class 'sage.categories.category.JoinCategory_with_category'&gt;</span>
<span class="sd">            sage: TFFC.super_categories()</span>
<span class="sd">            [Category of facade commutative test objects,</span>
<span class="sd">             Category of finite dimensional commutative test objects]</span>
<span class="sd">        """</span>
        <span class="c1"># Get the list of categories and deal with some trivial cases</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">categories</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Since Objects() is the top category, it is the neutral element of join</span>
                <span class="kn">from</span> <span class="nn">.objects</span> <span class="k">import</span> <span class="n">Objects</span>
                <span class="k">return</span> <span class="n">Objects</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">categories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">category</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">categories</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">category</span>

        <span class="c1"># Get the cache key, and look into the cache</span>
        <span class="c1"># Ensure associativity and commutativity by flattening</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># - Do we want to store the cache after or before the mangling of the categories?</span>
        <span class="c1"># - Caching with ignore_axioms?</span>
        <span class="c1"># JoinCategory's sorting, and removing duplicates</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="n">_sort_uniq</span><span class="p">(</span><span class="n">_flatten_categories</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_axioms</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">_join_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">_super_categories</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Handle axioms</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">join_as_tuple</span><span class="p">(</span><span class="n">cache_key</span><span class="p">,</span> <span class="n">axioms</span><span class="p">,</span> <span class="n">ignore_axioms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">JoinCategory</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_axioms</span><span class="p">:</span>
            <span class="n">_join_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">category</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the category of this category. So far, all categories</span>
<span class="sd">        are in the category of objects.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets().category()</span>
<span class="sd">            Category of objects</span>
<span class="sd">            sage: VectorSpaces(QQ).category()</span>
<span class="sd">            Category of objects</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">.objects</span> <span class="k">import</span> <span class="n">Objects</span>
        <span class="k">return</span> <span class="n">Objects</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns an object in this category. Most of the time, this is a parent.</span>

<span class="sd">        This serves three purposes:</span>

<span class="sd">        - Give a typical example to better explain what the category is all about.</span>
<span class="sd">          (and by the way prove that the category is non empty :-) )</span>
<span class="sd">        - Provide a minimal template for implementing other objects in this category</span>
<span class="sd">        - Provide an object on which to test generic code implemented by the category</span>

<span class="sd">        For all those applications, the implementation of the object</span>
<span class="sd">        shall be kept to a strict minimum. The object is therefore not</span>
<span class="sd">        meant to be used for other applications; most of the time a</span>
<span class="sd">        full featured version is available elsewhere in Sage, and</span>
<span class="sd">        should be used instead.</span>

<span class="sd">        Technical note: by default ``FooBar(...).example()`` is</span>
<span class="sd">        constructed by looking up</span>
<span class="sd">        ``sage.categories.examples.foo_bar.Example`` and calling it as</span>
<span class="sd">        ``Example()``. Extra positional or named parameters are also</span>
<span class="sd">        passed down. For a category over base ring, the base ring is</span>
<span class="sd">        further passed down as an optional argument.</span>

<span class="sd">        Categories are welcome to override this default implementation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Semigroups().example()</span>
<span class="sd">            An example of a semigroup: the left zero semigroup</span>

<span class="sd">            sage: Monoids().Subquotients().example()</span>
<span class="sd">            NotImplemented</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="s1">'.'</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span>
            <span class="c1"># this magic should not apply to nested categories like Monoids.Subquotients</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">module_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"sage.categories"</span><span class="p">,</span> <span class="s2">"sage.categories.examples"</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">sys</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">__import__</span><span class="p">(</span><span class="n">module_name</span><span class="p">)</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">Example</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="c1"># Add the base ring as optional argument if this is a category over base ring</span>
        <span class="k">if</span> <span class="s2">"base_ring"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keywords</span><span class="p">[</span><span class="s2">"base_ring"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_Category</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Returns True if x is a category.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: sage.categories.category.is_Category(CommutativeAdditiveSemigroups())</span>
<span class="sd">        True</span>
<span class="sd">        sage: sage.categories.category.is_Category(ZZ)</span>
<span class="sd">        False</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span>

<span class="nd">@cached_function</span>
<span class="k">def</span> <span class="nf">category_sample</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Return a sample of categories.</span>

<span class="sd">    It is constructed by looking for all concrete category classes declared in</span>
<span class="sd">    ``sage.categories.all``, calling :meth:`Category.an_instance` on those and</span>
<span class="sd">    taking all their super categories.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from sage.categories.category import category_sample</span>
<span class="sd">        sage: sorted(category_sample(), key=str)</span>
<span class="sd">        [Category of G-sets for Symmetric group of order 8! as a permutation group,</span>
<span class="sd">         Category of Hecke modules over Rational Field,</span>
<span class="sd">         Category of Lie algebras over Rational Field,</span>
<span class="sd">         Category of additive magmas, ...,</span>
<span class="sd">         Category of fields, ...,</span>
<span class="sd">         Category of graded hopf algebras with basis over Rational Field, ...,</span>
<span class="sd">         Category of modular abelian varieties over Rational Field, ...,</span>
<span class="sd">         Category of simplicial complexes, ...,</span>
<span class="sd">         Category of vector spaces over Rational Field, ...,</span>
<span class="sd">         Category of weyl groups, ...</span>
<span class="sd">    """</span>
    <span class="kn">import</span> <span class="nn">sage.categories.all</span>
    <span class="n">abstract_classes_for_categories</span> <span class="o">=</span> <span class="p">[</span><span class="n">Category</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">an_instance</span><span class="p">()</span>
                 <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                 <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">abstract_classes_for_categories</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">category_graph</span><span class="p">(</span><span class="n">categories</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Return the graph of the categories in Sage.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``categories`` -- a list (or iterable) of categories</span>

<span class="sd">    If ``categories`` is specified, then the graph contains the</span>
<span class="sd">    mentioned categories together with all their super</span>
<span class="sd">    categories. Otherwise the graph contains (an instance of) each</span>
<span class="sd">    category in :mod:`sage.categories.all` (e.g. ``Algebras(QQ)`` for</span>
<span class="sd">    algebras).</span>

<span class="sd">    For readability, the names of the category are shortened.</span>

<span class="sd">    .. TODO:: Further remove the base ring (see also :trac:`15801`).</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: G = sage.categories.category.category_graph(categories = [Groups()])</span>
<span class="sd">        sage: G.vertices()</span>
<span class="sd">        ['groups', 'inverse unital magmas', 'magmas', 'monoids', 'objects',</span>
<span class="sd">         'semigroups', 'sets', 'sets with partial maps', 'unital magmas']</span>
<span class="sd">        sage: G.plot()</span>
<span class="sd">        Graphics object consisting of 20 graphics primitives</span>

<span class="sd">        sage: sage.categories.category.category_graph().plot()</span>
<span class="sd">        Graphics object consisting of ... graphics primitives</span>
<span class="sd">    """</span>
    <span class="kn">from</span> <span class="nn">sage</span> <span class="k">import</span> <span class="n">graphs</span>
    <span class="k">if</span> <span class="n">categories</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="n">category_sample</span><span class="p">()</span>
    <span class="c1"># Include all the super categories</span>
    <span class="c1"># Get rid of join categories</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cat</span>
                     <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span>
                     <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">category</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">)))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">digraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
            <span class="c1"># Don't use super_categories() since it might contain join categories</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">([</span><span class="n">source</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">(),</span> <span class="n">target</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()])</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="c1">##############################################################################</span>
<span class="c1"># Parametrized categories whose parent/element class depend only on</span>
<span class="c1"># the super categories</span>
<span class="c1">##############################################################################</span>

<span class="k">class</span> <span class="nc">CategoryWithParameters</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A parametrized category whose parent/element classes depend only on</span>
<span class="sd">    its super categories.</span>

<span class="sd">    Many categories in Sage are parametrized, like ``C = Algebras(K)``</span>
<span class="sd">    which takes a base ring as parameter. In many cases, however, the</span>
<span class="sd">    operations provided by ``C`` in the parent class and element class</span>
<span class="sd">    depend only on the super categories of ``C``. For example, the</span>
<span class="sd">    vector space operations are provided if and only if ``K`` is a</span>
<span class="sd">    field, since ``VectorSpaces(K)`` is a super category of ``C`` only</span>
<span class="sd">    in that case. In such cases, and as an optimization (see :trac:`11935`),</span>
<span class="sd">    we want to use the same parent and element class for all fields.</span>
<span class="sd">    This is the purpose of this abstract class.</span>

<span class="sd">    Currently, :class:`~sage.categories.category.JoinCategory`,</span>
<span class="sd">    :class:`~sage.categories.category_types.Category_over_base` and</span>
<span class="sd">    :class:`~sage.categories.bimodules.Bimodules` inherit from this</span>
<span class="sd">    class.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: C1 = Algebras(GF(5))</span>
<span class="sd">        sage: C2 = Algebras(GF(3))</span>
<span class="sd">        sage: C3 = Algebras(ZZ)</span>
<span class="sd">        sage: from sage.categories.category import CategoryWithParameters</span>
<span class="sd">        sage: isinstance(C1, CategoryWithParameters)</span>
<span class="sd">        True</span>
<span class="sd">        sage: C1.parent_class is C2.parent_class</span>
<span class="sd">        True</span>
<span class="sd">        sage: C1.parent_class is C3.parent_class</span>
<span class="sd">        False</span>

<span class="sd">    .. automethod:: Category._make_named_class</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">_make_named_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span> <span class="n">cache</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the parent/element/... class of ``self``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``name`` -- a string; the name of the class as an attribute</span>
<span class="sd">          of ``self``</span>
<span class="sd">        - ``method_provider`` -- a string; the name of an attribute of</span>
<span class="sd">          ``self`` that provides methods for the new class (in</span>
<span class="sd">          addition to what comes from the super categories)</span>
<span class="sd">        - ``**options`` -- other named options to pass down to</span>
<span class="sd">          :meth:`Category._make_named_class`.</span>

<span class="sd">        ASSUMPTION:</span>

<span class="sd">        It is assumed that this method is only called from a lazy</span>
<span class="sd">        attribute whose name coincides with the given ``name``.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A dynamic class that has the corresponding named classes of</span>
<span class="sd">        the super categories of ``self`` as bases and contains the</span>
<span class="sd">        methods provided by ``getattr(self, method_provider)``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This method overrides :meth:`Category._make_named_class`</span>
<span class="sd">            so that the returned class *only* depends on the</span>
<span class="sd">            corresponding named classes of the super categories and on</span>
<span class="sd">            the provided methods. This allows for sharing the named</span>
<span class="sd">            classes across closely related categories providing the</span>
<span class="sd">            same code to their parents, elements and so on.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The categories of bimodules over the fields ``CC`` or ``RR``</span>
<span class="sd">        provide the same methods to their parents and elements::</span>

<span class="sd">            sage: Bimodules(ZZ,RR).parent_class is Bimodules(ZZ,RDF).parent_class #indirect doctest</span>
<span class="sd">            True</span>
<span class="sd">            sage: Bimodules(CC,ZZ).element_class is Bimodules(RR,ZZ).element_class</span>
<span class="sd">            True</span>

<span class="sd">        On the other hand, modules over a field have more methods than</span>
<span class="sd">        modules over a ring::</span>

<span class="sd">            sage: Modules(GF(3)).parent_class is Modules(ZZ).parent_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Modules(GF(3)).element_class is Modules(ZZ).element_class</span>
<span class="sd">            False</span>

<span class="sd">        For a more subtle example, one could possibly share the classes for</span>
<span class="sd">        ``GF(3)`` and ``GF(2^3, 'x')``, but this is not currently the case::</span>

<span class="sd">            sage: Modules(GF(3)).parent_class is Modules(GF(2^3,'x')).parent_class</span>
<span class="sd">            False</span>

<span class="sd">        This is because those two fields do not have the exact same category::</span>

<span class="sd">            sage: GF(3).category()</span>
<span class="sd">            Join of Category of finite enumerated fields</span>
<span class="sd">             and Category of subquotients of monoids</span>
<span class="sd">             and Category of quotients of semigroups</span>
<span class="sd">            sage: GF(2^3,'x').category()</span>
<span class="sd">            Category of finite enumerated fields</span>

<span class="sd">        Similarly for ``QQ`` and ``RR``::</span>

<span class="sd">            sage: QQ.category()</span>
<span class="sd">            Join of Category of number fields</span>
<span class="sd">             and Category of quotient fields</span>
<span class="sd">             and Category of metric spaces</span>
<span class="sd">            sage: RR.category()</span>
<span class="sd">            Join of Category of fields and Category of infinite sets and Category of complete metric spaces</span>
<span class="sd">            sage: Modules(QQ).parent_class is Modules(RR).parent_class</span>
<span class="sd">            False</span>

<span class="sd">        Some other cases where one could potentially share those classes::</span>

<span class="sd">            sage: Modules(GF(3),dispatch=False).parent_class  is Modules(ZZ).parent_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Modules(GF(3),dispatch=False).element_class is Modules(ZZ).element_class</span>
<span class="sd">            False</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: PC = Algebras(QQ).parent_class; PC   # indirect doctest</span>
<span class="sd">            &lt;class 'sage.categories.algebras.Algebras.parent_class'&gt;</span>
<span class="sd">            sage: type(PC)</span>
<span class="sd">            &lt;class 'sage.structure.dynamic_class.DynamicMetaclass'&gt;</span>
<span class="sd">            sage: PC.__bases__</span>
<span class="sd">            (&lt;class 'sage.categories.rings.Rings.parent_class'&gt;,</span>
<span class="sd">             &lt;class 'sage.categories.associative_algebras.AssociativeAlgebras.parent_class'&gt;,</span>
<span class="sd">             &lt;class 'sage.categories.unital_algebras.UnitalAlgebras.parent_class'&gt;)</span>
<span class="sd">            sage: loads(dumps(PC)) is PC</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DynamicMetaclass</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__base__</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class_key</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span>
                                            <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>


    <span class="nd">@abstract_method</span>
    <span class="k">def</span> <span class="nf">_make_named_class_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return what the element/parent/... class depend on.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``name`` -- a string; the name of the class as an attribute</span>
<span class="sd">          of ``self``</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`_make_named_class`</span>
<span class="sd">            - :meth:`sage.categories.category_types.Category_over_base._make_named_class_key`</span>
<span class="sd">            - :meth:`sage.categories.bimodules.Bimodules._make_named_class_key`</span>
<span class="sd">            - :meth:`JoinCategory._make_named_class_key`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The parent class of an algebra depends only on the category of the base ring::</span>

<span class="sd">            sage: Algebras(ZZ)._make_named_class_key("parent_class")</span>
<span class="sd">            Join of Category of euclidean domains</span>
<span class="sd">                 and Category of infinite enumerated sets</span>
<span class="sd">                 and Category of metric spaces</span>

<span class="sd">        The morphism class of a bimodule depends only on the category</span>
<span class="sd">        of the left and right base rings::</span>

<span class="sd">            sage: Bimodules(QQ, ZZ)._make_named_class_key("morphism_class")</span>
<span class="sd">            (Join of Category of number fields</span>
<span class="sd">                 and Category of quotient fields</span>
<span class="sd">                 and Category of metric spaces,</span>
<span class="sd">             Join of Category of euclidean domains</span>
<span class="sd">                 and Category of infinite enumerated sets</span>
<span class="sd">                 and Category of metric spaces)</span>

<span class="sd">        The element class of a join category depends only on the</span>
<span class="sd">        element class of its super categories::</span>

<span class="sd">            sage: Category.join([Groups(), Posets()])._make_named_class_key("element_class")</span>
<span class="sd">            (&lt;class 'sage.categories.groups.Groups.element_class'&gt;,</span>
<span class="sd">             &lt;class 'sage.categories.posets.Posets.element_class'&gt;)</span>
<span class="sd">        """</span>

    <span class="n">_make_named_class_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">_cmp_key</span> <span class="o">=</span> <span class="n">_cmp_key_named</span>

    <span class="k">def</span> <span class="nf">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A quick but partial test whether ``C`` is a subcategory of ``self``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``C`` -- a category</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        ``False``, if ``C.parent_class`` is not a subclass of</span>
<span class="sd">        ``self.parent_class``, and :obj:`~sage.misc.unknown.Unknown`</span>
<span class="sd">        otherwise.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Bimodules(QQ,QQ)._subcategory_hook_(Modules(QQ))</span>
<span class="sd">            Unknown</span>
<span class="sd">            sage: Bimodules(QQ,QQ)._subcategory_hook_(Rings())</span>
<span class="sd">            False</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">Unknown</span>

<span class="c1">#############################################################</span>
<span class="c1"># Join of several categories</span>
<span class="c1">#############################################################</span>

<span class="k">class</span> <span class="nc">JoinCategory</span><span class="p">(</span><span class="n">CategoryWithParameters</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A class for joins of several categories. Do not use directly;</span>
<span class="sd">    see Category.join instead.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from sage.categories.category import JoinCategory</span>
<span class="sd">        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J</span>
<span class="sd">        Join of Category of groups and Category of commutative additive monoids</span>
<span class="sd">        sage: J.super_categories()</span>
<span class="sd">        [Category of groups, Category of commutative additive monoids]</span>
<span class="sd">        sage: J.all_super_categories(proper=True)</span>
<span class="sd">        [Category of groups, ..., Category of magmas,</span>
<span class="sd">         Category of commutative additive monoids, ..., Category of additive magmas,</span>
<span class="sd">         Category of sets, Category of sets with partial maps, Category of objects]</span>

<span class="sd">    By :trac:`11935`, join categories and categories over base rings</span>
<span class="sd">    inherit from :class:`CategoryWithParameters`. This allows for</span>
<span class="sd">    sharing parent and element classes between similar categories. For</span>
<span class="sd">    example, since group algebras belong to a join category and since</span>
<span class="sd">    the underlying implementation is the same for all finite fields,</span>
<span class="sd">    we have::</span>

<span class="sd">        sage: G = SymmetricGroup(10)</span>
<span class="sd">        sage: A3 = G.algebra(GF(3))</span>
<span class="sd">        sage: A5 = G.algebra(GF(5))</span>
<span class="sd">        sage: type(A3.category())</span>
<span class="sd">        &lt;class 'sage.categories.category.JoinCategory_with_category'&gt;</span>
<span class="sd">        sage: type(A3) is type(A5)</span>
<span class="sd">        True</span>

<span class="sd">    .. automethod:: Category._repr_object_names</span>
<span class="sd">    .. automethod:: Category._repr_</span>
<span class="sd">    .. automethod:: Category._without_axioms</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">super_categories</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Initializes this JoinCategory</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - super_categories -- Categories to join.  This category will</span>
<span class="sd">          consist of objects and morphisms that lie in all of these</span>
<span class="sd">          categories.</span>

<span class="sd">        - name -- An optional name for this category.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from sage.categories.category import JoinCategory</span>
<span class="sd">            sage: C = JoinCategory((Groups(), CommutativeAdditiveMonoids())); C</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>
<span class="sd">            sage: TestSuite(C).run()</span>

<span class="sd">        """</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">super_categories</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">)</span> <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">super_categories</span><span class="p">))</span>
        <span class="c1"># Use __super_categories to not overwrite the lazy attribute Category._super_categories</span>
        <span class="c1"># Maybe this would not be needed if the flattening/sorting is does consistently?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__super_categories</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">super_categories</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">'name'</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">Category</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwds</span><span class="p">[</span><span class="s1">'name'</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Category</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_named_class_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return what the element/parent/... classes depend on.</span>

<span class="sd">        Since :trac:`11935`, the element/parent classes of a join</span>
<span class="sd">        category over base only depend on the element/parent class of</span>
<span class="sd">        its super categories.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`CategoryWithParameters`</span>
<span class="sd">            - :meth:`CategoryWithParameters._make_named_class_key`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Modules(ZZ)._make_named_class_key('element_class')</span>
<span class="sd">            Join of Category of euclidean domains</span>
<span class="sd">                 and Category of infinite enumerated sets</span>
<span class="sd">                 and Category of metric spaces</span>
<span class="sd">            sage: Modules(QQ)._make_named_class_key('parent_class')</span>
<span class="sd">            Join of Category of number fields</span>
<span class="sd">             and Category of quotient fields</span>
<span class="sd">             and Category of metric spaces</span>
<span class="sd">            sage: Schemes(Spec(ZZ))._make_named_class_key('parent_class')</span>
<span class="sd">            Category of schemes</span>
<span class="sd">            sage: ModularAbelianVarieties(QQ)._make_named_class_key('parent_class')</span>
<span class="sd">            Join of Category of number fields</span>
<span class="sd">             and Category of quotient fields</span>
<span class="sd">             and Category of metric spaces</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the immediate super categories, as per :meth:`Category.super_categories`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from sage.categories.category import JoinCategory</span>
<span class="sd">            sage: JoinCategory((Semigroups(), FiniteEnumeratedSets())).super_categories()</span>
<span class="sd">            [Category of semigroups, Category of finite enumerated sets]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__super_categories</span>

    <span class="k">def</span> <span class="nf">additional_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return ``None``.</span>

<span class="sd">        Indeed, a join category defines no additional structure.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category.additional_structure`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Modules(ZZ).additional_structure()</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns whether ``category`` is a subcategory of this join category</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``category`` -- a category.</span>

<span class="sd">        .. note::</span>

<span class="sd">            ``category`` is a sub-category of this join category if</span>
<span class="sd">            and only if it is a sub-category of all super categories</span>
<span class="sd">            of this join category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: base_cat = Category.join([NumberFields(), QuotientFields().Metric()])</span>
<span class="sd">            sage: cat = Category.join([Rings(), VectorSpaces(base_cat)])</span>
<span class="sd">            sage: QQ['x'].category().is_subcategory(cat)  # indirect doctest</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">category</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Check whether this join category is subcategory of another</span>
<span class="sd">        category ``C``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category.join([Rings(),Modules(QQ)]).is_subcategory(Category.join([Rngs(),Bimodules(QQ,QQ)]))</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">hook</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="n">Unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hook</span>

    <span class="k">def</span> <span class="nf">_with_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the category obtained by adding an axiom to ``self``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This is just an optimization of</span>
<span class="sd">            :meth:`Category._with_axiom`; it's not necessarily</span>
<span class="sd">            actually useful.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Category.join([Monoids(), Posets()])</span>
<span class="sd">            sage: C._with_axioms(["Finite"])</span>
<span class="sd">            Join of Category of finite monoids and Category of finite posets</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Check that axiom categories for a join are reconstructed from</span>
<span class="sd">        the base categories::</span>

<span class="sd">            sage: C = Category.join([Monoids(), Magmas().Commutative()])</span>
<span class="sd">            sage: C._with_axioms(["Finite"])</span>
<span class="sd">            Category of finite commutative monoids</span>

<span class="sd">        This helps guaranteeing commutativity of taking axioms::</span>

<span class="sd">            sage: Monoids().Finite().Commutative() is Monoids().Commutative().Finite()</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">cat</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">])</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_without_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return this category with axiom ``axiom`` removed.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A category ``C`` which does not have axiom ``axiom`` and such</span>
<span class="sd">        that either ``C`` is ``self``, or adding back all the</span>
<span class="sd">        axioms of ``self`` gives back ``self``.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category._without_axiom`</span>

<span class="sd">        .. WARNING:: This is not guaranteed to be robust.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Posets() &amp; FiniteEnumeratedSets() &amp; Sets().Facade(); C</span>
<span class="sd">            Category of facade finite enumerated posets</span>
<span class="sd">            sage: C._without_axiom("Facade")</span>
<span class="sd">            Category of finite enumerated posets</span>

<span class="sd">            sage: C = Sets().Finite().Facade()</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class 'sage.categories.category.JoinCategory_with_category'&gt;</span>
<span class="sd">            sage: C._without_axiom("Facade")</span>
<span class="sd">            Category of finite sets</span>
<span class="sd">        """</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_without_axiom</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">axiom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">_with_axioms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_without_axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        When adjoining axioms to a category, one often gets a join</span>
<span class="sd">        category; this method tries to recover the original</span>
<span class="sd">        category from this join category.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``named`` -- a boolean (default: ``False``)</span>

<span class="sd">        See :meth:`Category._without_axioms` for the description</span>
<span class="sd">        of the ``named`` parameter.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Category.join([Monoids(), Posets()]).Finite()</span>
<span class="sd">            sage: C._repr_(as_join=True)</span>
<span class="sd">            'Join of Category of finite monoids and Category of finite posets'</span>
<span class="sd">            sage: C._without_axioms()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: This join category isn't built by adding axioms to a single category</span>
<span class="sd">            sage: C = Monoids().Infinite()</span>
<span class="sd">            sage: C._repr_(as_join=True)</span>
<span class="sd">            'Join of Category of monoids and Category of infinite sets'</span>
<span class="sd">            sage: C._without_axioms()</span>
<span class="sd">            Category of magmas</span>
<span class="sd">            sage: C._without_axioms(named=True)</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        TESTS:</span>

<span class="sd">        ``C`` is in fact a join category::</span>

<span class="sd">            sage: from sage.categories.category import JoinCategory</span>
<span class="sd">            sage: isinstance(C, JoinCategory)</span>
<span class="sd">            True</span>
<span class="sd">        """</span>
        <span class="n">axioms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">category</span><span class="o">.</span><span class="n">_with_axioms</span><span class="p">(</span><span class="n">axioms</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">category</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="n">named</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"This join category isn't built by adding axioms"</span>
                         <span class="s2">" to a single category"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cmp_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return a comparison key for ``self``.</span>

<span class="sd">        See :meth:`Category._cmp_key` for the specifications.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        This raises an error since ``_cmp_key`` should not be called</span>
<span class="sd">        on join categories::</span>

<span class="sd">            sage: (Magmas() &amp; CommutativeAdditiveSemigroups())._cmp_key()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: _cmp_key should not be called on join categories</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"_cmp_key should not be called on join categories"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_object_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return the name of the objects of this category.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category._repr_object_names`, :meth:`_repr_`, :meth:`._without_axioms`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Groups().Finite().Commutative()._repr_(as_join=True)</span>
<span class="sd">            'Join of Category of finite groups and Category of commutative groups'</span>
<span class="sd">            sage: Groups().Finite().Commutative()._repr_object_names()</span>
<span class="sd">            'finite commutative groups'</span>

<span class="sd">        This uses :meth:`._without_axioms` which may fail if this</span>
<span class="sd">        category is not obtained by adjoining axioms to some super</span>
<span class="sd">        categories::</span>

<span class="sd">            sage: Category.join((Groups(), CommutativeAdditiveMonoids()))._repr_object_names()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: This join category isn't built by adding axioms to a single category</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="k">import</span> <span class="n">CategoryWithAxiom</span>
        <span class="k">return</span> <span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names_static</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_join</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Print representation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_join`` -- a boolean (default: False)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category.join((Groups(), CommutativeAdditiveMonoids())) #indirect doctest</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>

<span class="sd">        By default, when a join category is built from category by</span>
<span class="sd">        adjoining axioms, a nice name is printed out::</span>

<span class="sd">            sage: Groups().Facade().Finite()</span>
<span class="sd">            Category of facade finite groups</span>

<span class="sd">        But this is in fact really a join category::</span>

<span class="sd">            sage: Groups().Facade().Finite()._repr_(as_join = True)</span>
<span class="sd">            'Join of Category of finite groups and Category of facade sets'</span>

<span class="sd">        The rationale is to make it more readable, and hide the</span>
<span class="sd">        technical details of how this category is constructed</span>
<span class="sd">        internally, especially since this construction is likely to</span>
<span class="sd">        change over time when new axiom categories are implemented.</span>

<span class="sd">        This join category may possibly be obtained by adding axioms</span>
<span class="sd">        to different categories; so the result is not guaranteed to be</span>
<span class="sd">        unique; when this is not the case the first found is used.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category._repr_`, :meth:`_repr_object_names`</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: Category.join((Sets().Facade(), Groups()))</span>
<span class="sd">            Category of facade groups</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_join</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">JoinCategory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="s2">"Join of "</span> <span class="o">+</span> <span class="s2">" and "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>



</pre></div>
      </article>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
              Copyright &#169; 2021, Pieter Belmans
            |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensionsr": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"], "tex2jax": {"inlineMath": [["$", "$"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]]}})</script>
    <script src="../../../_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>