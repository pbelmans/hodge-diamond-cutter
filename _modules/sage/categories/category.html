
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sage.categories.category &#8212; Hodge diamond cutter v1.2 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script src="../../../_static/documentation_options.js?v=38d79a3d"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/sage/categories/category';</script>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
<script defer data-domain="cutter.ncag.info" src="https://plausible.io/js/script.js"></script>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Hodge diamond cutter v1.2 documentation - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Hodge diamond cutter v1.2 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for sage.categories.category</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Categories</span>

<span class="sd">AUTHORS:</span>

<span class="sd">- David Kohel, William Stein and Nicolas M. Thiery</span>

<span class="sd">Every Sage object lies in a category. Categories in Sage are</span>
<span class="sd">modeled on the mathematical idea of category, and are distinct from</span>
<span class="sd">Python classes, which are a programming construct.</span>

<span class="sd">In most cases, typing ``x.category()`` returns the category to which ``x``</span>
<span class="sd">belongs. If ``C`` is a category and ``x`` is any object, ``C(x)`` tries to</span>
<span class="sd">make an object in ``C`` from ``x``. Checking if ``x`` belongs to ``C`` is done</span>
<span class="sd">as usually by ``x in C``.</span>

<span class="sd">See :class:`Category` and :mod:`sage.categories.primer` for more details.</span>

<span class="sd">EXAMPLES:</span>

<span class="sd">We create a couple of categories::</span>

<span class="sd">    sage: Sets()</span>
<span class="sd">    Category of sets</span>
<span class="sd">    sage: GSets(AbelianGroup([2, 4, 9]))                                                # needs sage.groups</span>
<span class="sd">    Category of G-sets for Multiplicative Abelian group isomorphic to C2 x C4 x C9</span>
<span class="sd">    sage: Semigroups()</span>
<span class="sd">    Category of semigroups</span>
<span class="sd">    sage: VectorSpaces(FiniteField(11))</span>
<span class="sd">    Category of vector spaces over Finite Field of size 11</span>
<span class="sd">    sage: Ideals(IntegerRing())</span>
<span class="sd">    Category of ring ideals in Integer Ring</span>

<span class="sd">Let&#39;s request the category of some objects::</span>

<span class="sd">    sage: V = VectorSpace(RationalField(), 3)                                           # needs sage.modules</span>
<span class="sd">    sage: V.category()                                                                  # needs sage.modules</span>
<span class="sd">    Category of finite dimensional vector spaces with basis</span>
<span class="sd">     over (number fields and quotient fields and metric spaces)</span>

<span class="sd">    sage: G = SymmetricGroup(9)                                                         # needs sage.groups</span>
<span class="sd">    sage: G.category()                                                                  # needs sage.groups</span>
<span class="sd">    Join of</span>
<span class="sd">     Category of finite enumerated permutation groups and</span>
<span class="sd">     Category of finite Weyl groups and</span>
<span class="sd">     Category of well generated finite irreducible complex reflection groups</span>

<span class="sd">    sage: P = PerfectMatchings(3)                                                       # needs sage.combinat</span>
<span class="sd">    sage: P.category()                                                                  # needs sage.combinat</span>
<span class="sd">    Category of finite enumerated sets</span>

<span class="sd">Let&#39;s check some memberships::</span>

<span class="sd">    sage: V in VectorSpaces(QQ)                                                         # needs sage.modules</span>
<span class="sd">    True</span>
<span class="sd">    sage: V in VectorSpaces(FiniteField(11))                                            # needs sage.modules</span>
<span class="sd">    False</span>
<span class="sd">    sage: G in Monoids()                                                                # needs sage.groups</span>
<span class="sd">    True</span>
<span class="sd">    sage: P in Rings()                                                                  # needs sage.combinat</span>
<span class="sd">    False</span>

<span class="sd">For parametrized categories one can use the following shorthand::</span>

<span class="sd">    sage: V in VectorSpaces                                                             # needs sage.modules</span>
<span class="sd">    True</span>
<span class="sd">    sage: G in VectorSpaces                                                             # needs sage.groups</span>
<span class="sd">    False</span>

<span class="sd">A parent ``P`` is in a category ``C`` if ``P.category()`` is a subcategory of</span>
<span class="sd">``C``.</span>

<span class="sd">.. note::</span>

<span class="sd">    Any object of a category should be an instance of</span>
<span class="sd">    :class:`~sage.structure.category_object.CategoryObject`.</span>

<span class="sd">    For backward compatibility this is not yet enforced::</span>

<span class="sd">        sage: class A:</span>
<span class="sd">        ....:   def category(self):</span>
<span class="sd">        ....:       return Fields()</span>
<span class="sd">        sage: A() in Rings()</span>
<span class="sd">        True</span>

<span class="sd">    By default, the category of an element `x` of a parent `P` is the category</span>
<span class="sd">    of all objects of `P` (this is dubious and may be deprecated)::</span>

<span class="sd">        sage: V = VectorSpace(RationalField(), 3)                                       # needs sage.modules</span>
<span class="sd">        sage: v = V.gen(1)                                                              # needs sage.modules</span>
<span class="sd">        sage: v.category()                                                              # needs sage.modules</span>
<span class="sd">        Category of elements of Vector space of dimension 3 over Rational Field</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># ****************************************************************************</span>
<span class="c1">#  Copyright (C) 2005      David Kohel &lt;kohel@maths.usyd.edu&gt; and</span>
<span class="c1">#                          William Stein &lt;wstein@math.ucsd.edu&gt;</span>
<span class="c1">#                2008-2014 Nicolas M. Thiery &lt;nthiery at users.sf.net&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#                  https://www.gnu.org/licenses/</span>
<span class="c1"># ****************************************************************************</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">sage.misc.abstract_method</span> <span class="kn">import</span> <span class="n">abstract_method</span><span class="p">,</span> <span class="n">abstract_methods_of_class</span>
<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="kn">import</span> <span class="n">cached_method</span><span class="p">,</span> <span class="n">cached_function</span>
<span class="kn">from</span> <span class="nn">sage.misc.c3_controlled</span> <span class="kn">import</span> <span class="n">_cmp_key</span><span class="p">,</span> <span class="n">_cmp_key_named</span><span class="p">,</span> <span class="n">C3_sorted_merge</span>
<span class="kn">from</span> <span class="nn">sage.misc.lazy_attribute</span> <span class="kn">import</span> <span class="n">lazy_attribute</span>
<span class="kn">from</span> <span class="nn">sage.misc.unknown</span> <span class="kn">import</span> <span class="n">Unknown</span>
<span class="kn">from</span> <span class="nn">sage.misc.weak_dict</span> <span class="kn">import</span> <span class="n">WeakValueDictionary</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="kn">import</span> <span class="n">SageObject</span>
<span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="kn">from</span> <span class="nn">sage.structure.dynamic_class</span> <span class="kn">import</span> <span class="n">DynamicMetaclass</span><span class="p">,</span> <span class="n">dynamic_class</span>

<span class="kn">from</span> <span class="nn">sage.categories.category_cy_helper</span> <span class="kn">import</span> <span class="n">category_sort_key</span><span class="p">,</span> <span class="n">_sort_uniq</span><span class="p">,</span> <span class="n">_flatten_categories</span><span class="p">,</span> <span class="n">join_as_tuple</span>

<span class="n">_join_cache</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>


<span class="n">HALL_OF_FAME</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Coxeter&#39;</span><span class="p">,</span> <span class="s1">&#39;Hopf&#39;</span><span class="p">,</span> <span class="s1">&#39;Weyl&#39;</span><span class="p">,</span> <span class="s1">&#39;Lie&#39;</span><span class="p">,</span> <span class="s1">&#39;Hecke&#39;</span><span class="p">,</span> <span class="s1">&#39;Dedekind&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Category</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for modeling mathematical categories, like for example:</span>

<span class="sd">    - ``Groups()``: the category of groups</span>
<span class="sd">    - ``EuclideanDomains()``: the category of euclidean rings</span>
<span class="sd">    - ``VectorSpaces(QQ)``: the category of vector spaces over the field of</span>
<span class="sd">      rationals</span>

<span class="sd">    See :mod:`sage.categories.primer` for an introduction to</span>
<span class="sd">    categories in Sage, their relevance, purpose, and usage. The</span>
<span class="sd">    documentation below will focus on their implementation.</span>

<span class="sd">    Technically, a category is an instance of the class</span>
<span class="sd">    :class:`Category` or some of its subclasses. Some categories, like</span>
<span class="sd">    :class:`VectorSpaces`, are parametrized: ``VectorSpaces(QQ)`` is one of</span>
<span class="sd">    many instances of the class :class:`VectorSpaces`. On the other</span>
<span class="sd">    hand, ``EuclideanDomains()`` is the single instance of the class</span>
<span class="sd">    :class:`EuclideanDomains`.</span>

<span class="sd">    Recall that an algebraic structure (say, the ring `\QQ[x]`) is</span>
<span class="sd">    modelled in Sage by an object which is called a parent. This</span>
<span class="sd">    object belongs to certain categories (here ``EuclideanDomains()`` and</span>
<span class="sd">    ``Algebras()``). The elements of the ring are themselves objects.</span>

<span class="sd">    The class of a category (say :class:`EuclideanDomains`) can define simultaneously:</span>

<span class="sd">    - Operations on the category itself (what is its super categories?</span>
<span class="sd">      its category of morphisms? its dual category?).</span>
<span class="sd">    - Generic operations on parents in this category, like the ring `\QQ[x]`.</span>
<span class="sd">    - Generic operations on elements of such parents (e. g., the</span>
<span class="sd">      Euclidean algorithm for computing gcds).</span>
<span class="sd">    - Generic operations on morphisms of this category.</span>

<span class="sd">    This is achieved as follows::</span>

<span class="sd">        sage: from sage.categories.category import Category</span>
<span class="sd">        sage: class EuclideanDomains(Category):</span>
<span class="sd">        ....:     # operations on the category itself</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         [Rings()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     def dummy(self): # TODO: find some good examples</span>
<span class="sd">        ....:          pass</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods: # holds the generic operations on parents</span>
<span class="sd">        ....:          # TODO: find a good example of an operation</span>
<span class="sd">        ....:          pass</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ElementMethods:# holds the generic operations on elements</span>
<span class="sd">        ....:          def gcd(x,y):</span>
<span class="sd">        ....:              # Euclid algorithms</span>
<span class="sd">        ....:              pass</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class MorphismMethods: # holds the generic operations on morphisms</span>
<span class="sd">        ....:          # TODO: find a good example of an operation</span>
<span class="sd">        ....:          pass</span>
<span class="sd">        ....:</span>

<span class="sd">    Note that the nested class ``ParentMethods`` is merely a container</span>
<span class="sd">    of operations, and does not inherit from anything. Instead, the</span>
<span class="sd">    hierarchy relation is defined once at the level of the categories,</span>
<span class="sd">    and the actual hierarchy of classes is built in parallel from all</span>
<span class="sd">    the ``ParentMethods`` nested classes, and stored in the attributes</span>
<span class="sd">    ``parent_class``. Then, a parent in a category ``C`` receives the</span>
<span class="sd">    appropriate operations from all the super categories by usual</span>
<span class="sd">    class inheritance from ``C.parent_class``.</span>

<span class="sd">    Similarly, two other hierarchies of classes, for elements and</span>
<span class="sd">    morphisms respectively, are built from all the ``ElementMethods``</span>
<span class="sd">    and ``MorphismMethods`` nested classes.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    We define a hierarchy of four categories ``As()``, ``Bs()``,</span>
<span class="sd">    ``Cs()``, ``Ds()`` with a diamond inheritance. Think for example:</span>

<span class="sd">    - ``As()``: the category of sets</span>
<span class="sd">    - ``Bs()``: the category of additive groups</span>
<span class="sd">    - ``Cs()``: the category of multiplicative monoids</span>
<span class="sd">    - ``Ds()``: the category of rings</span>

<span class="sd">    ::</span>

<span class="sd">        sage: from sage.categories.category import Category</span>
<span class="sd">        sage: from sage.misc.lazy_attribute import lazy_attribute</span>
<span class="sd">        sage: class As (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return []</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fA(self):</span>
<span class="sd">        ....:             return &quot;A&quot;</span>
<span class="sd">        ....:         f = fA</span>

<span class="sd">        sage: class Bs (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return [As()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fB(self):</span>
<span class="sd">        ....:             return &quot;B&quot;</span>

<span class="sd">        sage: class Cs (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return [As()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fC(self):</span>
<span class="sd">        ....:             return &quot;C&quot;</span>
<span class="sd">        ....:         f = fC</span>

<span class="sd">        sage: class Ds (Category):</span>
<span class="sd">        ....:     def super_categories(self):</span>
<span class="sd">        ....:         return [Bs(),Cs()]</span>
<span class="sd">        ....:</span>
<span class="sd">        ....:     class ParentMethods:</span>
<span class="sd">        ....:         def fD(self):</span>
<span class="sd">        ....:             return &quot;D&quot;</span>

<span class="sd">    Categories should always have unique representation; by :issue:`12215`,</span>
<span class="sd">    this means that it will be kept in cache, but only</span>
<span class="sd">    if there is still some strong reference to it.</span>

<span class="sd">    We check this before proceeding::</span>

<span class="sd">        sage: import gc</span>
<span class="sd">        sage: idAs = id(As())</span>
<span class="sd">        sage: _ = gc.collect()</span>
<span class="sd">        sage: n == id(As())</span>
<span class="sd">        False</span>
<span class="sd">        sage: a = As()</span>
<span class="sd">        sage: id(As()) == id(As())</span>
<span class="sd">        True</span>
<span class="sd">        sage: As().parent_class == As().parent_class</span>
<span class="sd">        True</span>

<span class="sd">    We construct a parent in the category ``Ds()`` (that, is an instance</span>
<span class="sd">    of ``Ds().parent_class``), and check that it has access to all the</span>
<span class="sd">    methods provided by all the categories, with the appropriate</span>
<span class="sd">    inheritance order::</span>

<span class="sd">        sage: D = Ds().parent_class()</span>
<span class="sd">        sage: [ D.fA(), D.fB(), D.fC(), D.fD() ]</span>
<span class="sd">        [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</span>
<span class="sd">        sage: D.f()</span>
<span class="sd">        &#39;C&#39;</span>

<span class="sd">    ::</span>

<span class="sd">        sage: C = Cs().parent_class()</span>
<span class="sd">        sage: [ C.fA(), C.fC() ]</span>
<span class="sd">        [&#39;A&#39;, &#39;C&#39;]</span>
<span class="sd">        sage: C.f()</span>
<span class="sd">        &#39;C&#39;</span>

<span class="sd">    Here is the parallel hierarchy of classes which has been built</span>
<span class="sd">    automatically, together with the method resolution order (``.mro()``)::</span>

<span class="sd">        sage: As().parent_class</span>
<span class="sd">        &lt;class &#39;__main__.As.parent_class&#39;&gt;</span>
<span class="sd">        sage: As().parent_class.__bases__</span>
<span class="sd">        (&lt;... &#39;object&#39;&gt;,)</span>
<span class="sd">        sage: As().parent_class.mro()</span>
<span class="sd">        [&lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;]</span>

<span class="sd">    ::</span>

<span class="sd">        sage: Bs().parent_class</span>
<span class="sd">        &lt;class &#39;__main__.Bs.parent_class&#39;&gt;</span>
<span class="sd">        sage: Bs().parent_class.__bases__</span>
<span class="sd">        (&lt;class &#39;__main__.As.parent_class&#39;&gt;,)</span>
<span class="sd">        sage: Bs().parent_class.mro()</span>
<span class="sd">        [&lt;class &#39;__main__.Bs.parent_class&#39;&gt;, &lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;]</span>

<span class="sd">    ::</span>

<span class="sd">        sage: Cs().parent_class</span>
<span class="sd">        &lt;class &#39;__main__.Cs.parent_class&#39;&gt;</span>
<span class="sd">        sage: Cs().parent_class.__bases__</span>
<span class="sd">        (&lt;class &#39;__main__.As.parent_class&#39;&gt;,)</span>
<span class="sd">        sage: Cs().parent_class.__mro__</span>
<span class="sd">        (&lt;class &#39;__main__.Cs.parent_class&#39;&gt;, &lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;)</span>

<span class="sd">    ::</span>

<span class="sd">        sage: Ds().parent_class</span>
<span class="sd">        &lt;class &#39;__main__.Ds.parent_class&#39;&gt;</span>
<span class="sd">        sage: Ds().parent_class.__bases__</span>
<span class="sd">        (&lt;class &#39;__main__.Cs.parent_class&#39;&gt;, &lt;class &#39;__main__.Bs.parent_class&#39;&gt;)</span>
<span class="sd">        sage: Ds().parent_class.mro()</span>
<span class="sd">        [&lt;class &#39;__main__.Ds.parent_class&#39;&gt;, &lt;class &#39;__main__.Cs.parent_class&#39;&gt;,</span>
<span class="sd">         &lt;class &#39;__main__.Bs.parent_class&#39;&gt;, &lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;]</span>

<span class="sd">    Note that two categories in the same class need not have the</span>
<span class="sd">    same ``super_categories``. For example, ``Algebras(QQ)`` has</span>
<span class="sd">    ``VectorSpaces(QQ)`` as super category, whereas ``Algebras(ZZ)``</span>
<span class="sd">    only has ``Modules(ZZ)`` as super category. In particular, the</span>
<span class="sd">    constructed parent class and element class will differ (inheriting,</span>
<span class="sd">    or not, methods specific for vector spaces)::</span>

<span class="sd">        sage: Algebras(QQ).parent_class is Algebras(ZZ).parent_class</span>
<span class="sd">        False</span>
<span class="sd">        sage: issubclass(Algebras(QQ).parent_class, VectorSpaces(QQ).parent_class)</span>
<span class="sd">        True</span>

<span class="sd">    On the other hand, identical hierarchies of classes are,</span>
<span class="sd">    preferably, built only once (e.g. for categories over a base ring)::</span>

<span class="sd">        sage: Algebras(GF(5)).parent_class is Algebras(GF(7)).parent_class</span>
<span class="sd">        True</span>
<span class="sd">        sage: F = FractionField(ZZ[&#39;t&#39;])</span>
<span class="sd">        sage: Coalgebras(F).parent_class is Coalgebras(FractionField(F[&#39;x&#39;])).parent_class</span>
<span class="sd">        True</span>

<span class="sd">    We now construct a parent in the usual way::</span>

<span class="sd">        sage: class myparent(Parent):</span>
<span class="sd">        ....:     def __init__(self):</span>
<span class="sd">        ....:         Parent.__init__(self, category=Ds())</span>
<span class="sd">        ....:     def g(self):</span>
<span class="sd">        ....:         return &quot;myparent&quot;</span>
<span class="sd">        ....:     class Element():</span>
<span class="sd">        ....:         pass</span>
<span class="sd">        sage: D = myparent()</span>
<span class="sd">        sage: D.__class__</span>
<span class="sd">        &lt;class &#39;__main__.myparent_with_category&#39;&gt;</span>
<span class="sd">        sage: D.__class__.__bases__</span>
<span class="sd">        (&lt;class &#39;__main__.myparent&#39;&gt;, &lt;class &#39;__main__.Ds.parent_class&#39;&gt;)</span>
<span class="sd">        sage: D.__class__.mro()</span>
<span class="sd">        [&lt;class &#39;__main__.myparent_with_category&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.myparent&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;sage.structure.parent.Parent&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;sage.structure.category_object.CategoryObject&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;sage.structure.sage_object.SageObject&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.Ds.parent_class&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.Cs.parent_class&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.Bs.parent_class&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.As.parent_class&#39;&gt;,</span>
<span class="sd">        &lt;... &#39;object&#39;&gt;]</span>
<span class="sd">        sage: D.fA()</span>
<span class="sd">        &#39;A&#39;</span>
<span class="sd">        sage: D.fB()</span>
<span class="sd">        &#39;B&#39;</span>
<span class="sd">        sage: D.fC()</span>
<span class="sd">        &#39;C&#39;</span>
<span class="sd">        sage: D.fD()</span>
<span class="sd">        &#39;D&#39;</span>
<span class="sd">        sage: D.f()</span>
<span class="sd">        &#39;C&#39;</span>
<span class="sd">        sage: D.g()</span>
<span class="sd">        &#39;myparent&#39;</span>

<span class="sd">    ::</span>

<span class="sd">        sage: D.element_class</span>
<span class="sd">        &lt;class &#39;__main__.myparent_with_category.element_class&#39;&gt;</span>
<span class="sd">        sage: D.element_class.mro()</span>
<span class="sd">        [&lt;class &#39;__main__.myparent_with_category.element_class&#39;&gt;,</span>
<span class="sd">        &lt;class ...__main__....Element...&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.Ds.element_class&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.Cs.element_class&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.Bs.element_class&#39;&gt;,</span>
<span class="sd">        &lt;class &#39;__main__.As.element_class&#39;&gt;,</span>
<span class="sd">        &lt;... &#39;object&#39;&gt;]</span>


<span class="sd">    TESTS::</span>

<span class="sd">        sage: import __main__</span>
<span class="sd">        sage: __main__.myparent = myparent</span>
<span class="sd">        sage: __main__.As = As</span>
<span class="sd">        sage: __main__.Bs = Bs</span>
<span class="sd">        sage: __main__.Cs = Cs</span>
<span class="sd">        sage: __main__.Ds = Ds</span>
<span class="sd">        sage: loads(dumps(Ds)) is Ds</span>
<span class="sd">        True</span>
<span class="sd">        sage: loads(dumps(Ds())) is Ds()</span>
<span class="sd">        True</span>
<span class="sd">        sage: loads(dumps(Ds().element_class)) is Ds().element_class</span>
<span class="sd">        True</span>

<span class="sd">    .. automethod:: Category._super_categories</span>
<span class="sd">    .. automethod:: Category._super_categories_for_classes</span>
<span class="sd">    .. automethod:: Category._all_super_categories</span>
<span class="sd">    .. automethod:: Category._all_super_categories_proper</span>
<span class="sd">    .. automethod:: Category._set_of_super_categories</span>
<span class="sd">    .. automethod:: Category._make_named_class</span>
<span class="sd">    .. automethod:: Category._repr_</span>
<span class="sd">    .. automethod:: Category._repr_object_names</span>
<span class="sd">    .. automethod:: Category._test_category</span>
<span class="sd">    .. automethod:: Category._with_axiom</span>
<span class="sd">    .. automethod:: Category._with_axiom_as_tuple</span>
<span class="sd">    .. automethod:: Category._without_axioms</span>
<span class="sd">    .. automethod:: Category._sort</span>
<span class="sd">    .. automethod:: Category._sort_uniq</span>
<span class="sd">    .. automethod:: Category.__classcall__</span>
<span class="sd">    .. automethod:: Category.__init__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input mangling for unique representation.</span>

<span class="sd">        Let ``C = Cs(...)`` be a category. Since :issue:`12895`, the</span>
<span class="sd">        class of ``C`` is a dynamic subclass ``Cs_with_category`` of</span>
<span class="sd">        ``Cs`` in order for ``C`` to inherit code from the</span>
<span class="sd">        ``SubcategoryMethods`` nested classes of its super categories.</span>

<span class="sd">        The purpose of this ``__classcall__`` method is to ensure that</span>
<span class="sd">        reconstructing ``C`` from its class with</span>
<span class="sd">        ``Cs_with_category(...)`` actually calls properly ``Cs(...)``</span>
<span class="sd">        and gives back ``C``.</span>

<span class="sd">        .. SEEALSO:: :meth:`subcategory_class`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: A = Algebras(QQ)</span>
<span class="sd">            sage: A.__class__</span>
<span class="sd">            &lt;class &#39;sage.categories.algebras.Algebras_with_category&#39;&gt;</span>
<span class="sd">            sage: A is Algebras(QQ)</span>
<span class="sd">            True</span>
<span class="sd">            sage: A is A.__class__(QQ)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DynamicMetaclass</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__base__</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: class SemiprimitiveRings(Category):</span>
<span class="sd">            ....:     def super_categories(self):</span>
<span class="sd">            ....:         return [Rings()]</span>
<span class="sd">            ....:     class ParentMethods:</span>
<span class="sd">            ....:         def jacobson_radical(self):</span>
<span class="sd">            ....:             return self.ideal(0)</span>
<span class="sd">            sage: C = SemiprimitiveRings()</span>
<span class="sd">            sage: C</span>
<span class="sd">            Category of semiprimitive rings</span>
<span class="sd">            sage: C.__class__</span>
<span class="sd">            &lt;class &#39;__main__.SemiprimitiveRings_with_category&#39;&gt;</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            If the default name of the category (built from the name of</span>
<span class="sd">            the class) is not adequate, please implement</span>
<span class="sd">            :meth:`_repr_object_names` to customize it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">dynamic_class</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_with_category&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcategory_class</span><span class="p">,</span> <span class="p">),</span>
                                       <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">doccls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A short name of ``self``, obtained from its type.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._label</span>
<span class="sd">            &#39;Rings&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[:</span><span class="n">t</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_repr_object_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the name of the objects of this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: FiniteGroups()._repr_object_names()</span>
<span class="sd">            &#39;finite groups&#39;</span>
<span class="sd">            sage: AlgebrasWithBasis(QQ)._repr_object_names()</span>
<span class="sd">            &#39;algebras with basis over Rational Field&#39;</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: Rings()</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: Rings()._repr_object_names()</span>
<span class="sd">            &#39;rings&#39;</span>
<span class="sd">            sage: PrincipalIdealDomains()._repr_object_names()</span>
<span class="sd">            &#39;principal ideal domains&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">letter</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">letter</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;;&quot;</span> <span class="o">+</span> <span class="n">letter</span>
                        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">w</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">HALL_OF_FAME</span> <span class="k">else</span> <span class="n">w</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">)</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_short_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a CamelCase name for this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CoxeterGroups()._short_name()</span>
<span class="sd">            &#39;CoxeterGroups&#39;</span>

<span class="sd">            sage: AlgebrasWithBasis(QQ)._short_name()</span>
<span class="sd">            &#39;AlgebrasWithBasis&#39;</span>

<span class="sd">        Conventions for short names should be discussed at the level</span>
<span class="sd">        of Sage, and only then applied accordingly here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">an_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of this class.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings.an_instance()</span>
<span class="sd">            Category of rings</span>

<span class="sd">        Parametrized categories should overload this default</span>
<span class="sd">        implementation to provide appropriate arguments::</span>

<span class="sd">            sage: Algebras.an_instance()</span>
<span class="sd">            Category of algebras over Rational Field</span>
<span class="sd">            sage: Bimodules.an_instance()                                               # needs sage.rings.real_mpfr</span>
<span class="sd">            Category of bimodules over Rational Field on the left</span>
<span class="sd">             and Real Field with 53 bits of precision on the right</span>
<span class="sd">            sage: AlgebraIdeals.an_instance()</span>
<span class="sd">            Category of algebra ideals</span>
<span class="sd">             in Univariate Polynomial Ring in x over Rational Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an object in this category from the data in ``x``,</span>
<span class="sd">        or throw :class:`TypeError` or :class:`NotImplementedError`.</span>

<span class="sd">        If ``x`` is readily in ``self`` it is returned unchanged.</span>
<span class="sd">        Categories wishing to extend this minimal behavior should</span>
<span class="sd">        implement :meth:`._call_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()(ZZ)</span>
<span class="sd">            Integer Ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an object in this category from the data in ``x``,</span>
<span class="sd">        or throw :class:`NotImplementedError`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Semigroups()._call_(3)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the print representation of this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets() # indirect doctest</span>
<span class="sd">            Category of sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Category of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the latex representation of this category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: latex(Sets()) # indirect doctest</span>
<span class="sd">            \mathbf{Sets}</span>
<span class="sd">            sage: latex(CommutativeAdditiveSemigroups())</span>
<span class="sd">            \mathbf{CommutativeAdditiveSemigroups}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">mathbf{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_short_name</span><span class="p">()</span>

<span class="c1">#   The convention for which hash function to use should be decided at the level of UniqueRepresentation</span>
<span class="c1">#   The implementation below is bad (hash independent of the base ring)</span>
<span class="c1">#     def __hash__(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Returns a hash for this category.</span>
<span class="c1">#</span>
<span class="c1">#         Currently this is just the hash of the string representing the category.</span>
<span class="c1">#</span>
<span class="c1">#         EXAMPLES::</span>
<span class="c1">#</span>
<span class="c1">#             sage: hash(Algebras(QQ)) #indirect doctest</span>
<span class="c1">#             699942203</span>
<span class="c1">#             sage: hash(Algebras(ZZ))</span>
<span class="c1">#             699942203</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         return hash(self.__category) # Any reason not to use id?</span>

    <span class="k">def</span> <span class="nf">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quick subcategory check.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``category`` -- a category</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - ``True``, if ``category`` is a subcategory of ``self``.</span>
<span class="sd">        - ``False``, if ``category`` is not a subcategory of ``self``.</span>
<span class="sd">        - ``Unknown``, if a quick check was not enough to determine</span>
<span class="sd">          whether ``category`` is a subcategory of ``self`` or not.</span>

<span class="sd">        The aim of this method is to offer a framework to add cheap</span>
<span class="sd">        tests for subcategories. When doing</span>
<span class="sd">        ``category.is_subcategory(self)`` (note the reverse order of</span>
<span class="sd">        ``self`` and ``category``), this method is usually called</span>
<span class="sd">        first.  Only if it returns ``Unknown``, :meth:`is_subcategory`</span>
<span class="sd">        will build the list of super categories of ``category``.</span>

<span class="sd">        This method need not to handle the case where ``category`` is</span>
<span class="sd">        ``self``; this is the first test that is done in</span>
<span class="sd">        :meth:`is_subcategory`.</span>

<span class="sd">        This default implementation tests whether the parent class of</span>
<span class="sd">        ``category`` is a subclass of the parent class of ``self``.</span>
<span class="sd">        This is most of the time a complete subcategory test.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            This test is incomplete for categories in</span>
<span class="sd">            :class:`CategoryWithParameters`, as introduced by</span>
<span class="sd">            :issue:`11935`. This method is therefore overwritten by</span>
<span class="sd">            :meth:`~sage.categories.category.CategoryWithParameters._subcategory_hook_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._subcategory_hook_(Rings())</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">category</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Membership testing</span>

<span class="sd">        Returns whether ``x`` is an object in this category, that is</span>
<span class="sd">        if the category of ``x`` is a subcategory of ``self``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: ZZ in Sets()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__classcontains__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Membership testing, without arguments</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``cls`` -- a category class</span>
<span class="sd">        - ``x`` -- any object</span>

<span class="sd">        Returns whether ``x`` is an object of a category which is an instance</span>
<span class="sd">        of ``cls``.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        This method makes it easy to test if an object is, say, a</span>
<span class="sd">        vector space, without having to specify the base ring::</span>

<span class="sd">            sage: F = FreeModule(QQ, 3)                                                 # needs sage.modules</span>
<span class="sd">            sage: F in VectorSpaces                                                     # needs sage.modules</span>
<span class="sd">            True</span>

<span class="sd">            sage: F = FreeModule(ZZ, 3)                                                 # needs sage.modules</span>
<span class="sd">            sage: F in VectorSpaces                                                     # needs sage.modules</span>
<span class="sd">            False</span>

<span class="sd">            sage: F in Algebras                                                         # needs sage.modules</span>
<span class="sd">            False</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Non category objects shall be handled properly::</span>

<span class="sd">            sage: [1,2] in Algebras</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">categories</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_abelian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this category is abelian.</span>

<span class="sd">        An abelian category is a category satisfying:</span>

<span class="sd">        - It has a zero object;</span>
<span class="sd">        - It has all pullbacks and pushouts;</span>
<span class="sd">        - All monomorphisms and epimorphisms are normal.</span>

<span class="sd">        Equivalently, one can define an increasing sequence of conditions:</span>

<span class="sd">        - A category is pre-additive if it is enriched over abelian groups</span>
<span class="sd">          (all homsets are abelian groups and composition is bilinear);</span>
<span class="sd">        - A pre-additive category is additive if every finite set of objects</span>
<span class="sd">          has a biproduct (we can form direct sums and direct products);</span>
<span class="sd">        - An additive category is pre-abelian if every morphism has both a</span>
<span class="sd">          kernel and a cokernel;</span>
<span class="sd">        - A pre-abelian category is abelian if every monomorphism is the</span>
<span class="sd">          kernel of some morphism and every epimorphism is the cokernel of</span>
<span class="sd">          some morphism.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Modules(ZZ).is_abelian()</span>
<span class="sd">            True</span>
<span class="sd">            sage: FreeModules(ZZ).is_abelian()</span>
<span class="sd">            False</span>
<span class="sd">            sage: FreeModules(QQ).is_abelian()</span>
<span class="sd">            True</span>
<span class="sd">            sage: CommutativeAdditiveGroups().is_abelian()</span>
<span class="sd">            True</span>
<span class="sd">            sage: Semigroups().is_abelian()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: is_abelian</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;is_abelian&quot;</span><span class="p">)</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Methods related to the category hierarchy</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">category_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the graph of all super categories of this category</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ)</span>
<span class="sd">            sage: G = C.category_graph()                                                # needs sage.graphs</span>
<span class="sd">            sage: G.is_directed_acyclic()                                               # needs sage.graphs</span>
<span class="sd">            True</span>

<span class="sd">        The girth of a directed acyclic graph is infinite, however,</span>
<span class="sd">        the girth of the underlying undirected graph is 4 in this case::</span>

<span class="sd">            sage: Graph(G).girth()                                                      # needs sage.graphs</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">category_graph</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>

    <span class="nd">@abstract_method</span>
    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the *immediate* super categories of ``self``.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a duplicate-free list of categories.</span>

<span class="sd">        Every category should implement this method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Groups().super_categories()</span>
<span class="sd">            [Category of monoids, Category of inverse unital magmas]</span>
<span class="sd">            sage: Objects().super_categories()</span>
<span class="sd">            []</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Since :issue:`10963`, the order of the categories in the</span>
<span class="sd">            result is irrelevant. For details, see</span>
<span class="sd">            :ref:`category-primer-category-order`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Whenever speed matters, developers are advised to use the</span>
<span class="sd">            lazy attribute :meth:`_super_categories` instead of</span>
<span class="sd">            calling this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_all_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All the super categories of this category, including this category.</span>

<span class="sd">        Since :issue:`11943`, the order of super categories is</span>
<span class="sd">        determined by Python&#39;s method resolution order C3 algorithm.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_super_categories`</span>

<span class="sd">        .. note:: this attribute is likely to eventually become a tuple.</span>

<span class="sd">        .. note:: this sets :meth:`_super_categories_for_classes` as a side effect</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Rings(); C</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: C._all_super_categories</span>
<span class="sd">            [Category of rings, Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span> <span class="o">=</span> <span class="n">C3_sorted_merge</span><span class="p">([</span><span class="n">cat</span><span class="o">.</span><span class="n">_all_super_categories</span>
                                           <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">]</span> <span class="o">+</span>
                                          <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">],</span>
                                          <span class="n">category_sort_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">category_sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Inconsistent sorting results for all super categories of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories_for_classes</span> <span class="o">=</span> <span class="n">bases</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_all_super_categories_proper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All the proper super categories of this category.</span>

<span class="sd">        Since :issue:`11943`, the order of super categories is</span>
<span class="sd">        determined by Python&#39;s method resolution order C3 algorithm.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_super_categories`</span>

<span class="sd">        .. note:: this attribute is likely to eventually become a tuple.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Rings(); C</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: C._all_super_categories_proper</span>
<span class="sd">            [Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_set_of_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The frozen set of all proper super categories of this category.</span>

<span class="sd">        .. note:: this is used for speeding up category containment tests.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_super_categories`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: sorted(Groups()._set_of_super_categories, key=str)</span>
<span class="sd">            [Category of inverse unital magmas,</span>
<span class="sd">             Category of magmas,</span>
<span class="sd">             Category of monoids,</span>
<span class="sd">             Category of objects,</span>
<span class="sd">             Category of semigroups,</span>
<span class="sd">             Category of sets,</span>
<span class="sd">             Category of sets with partial maps,</span>
<span class="sd">             Category of unital magmas]</span>
<span class="sd">            sage: sorted(Groups()._set_of_super_categories, key=str)</span>
<span class="sd">            [Category of inverse unital magmas, Category of magmas, Category of monoids,</span>
<span class="sd">             Category of objects, Category of semigroups, Category of sets,</span>
<span class="sd">             Category of sets with partial maps, Category of unital magmas]</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: C = HopfAlgebrasWithBasis(GF(7))</span>
<span class="sd">            sage: C._set_of_super_categories == set(C._all_super_categories_proper)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories_proper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">all_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all super categories of this category.</span>

<span class="sd">        INPUT:</span>

<span class="sd">         - ``proper`` -- a boolean (default: ``False``); whether to exclude this category.</span>

<span class="sd">        Since :issue:`11943`, the order of super categories is</span>
<span class="sd">        determined by Python&#39;s method resolution order C3 algorithm.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Whenever speed matters, the developers are advised to use</span>
<span class="sd">            instead the lazy attributes :meth:`_all_super_categories`,</span>
<span class="sd">            :meth:`_all_super_categories_proper`, or</span>
<span class="sd">            :meth:`_set_of_super_categories`, as</span>
<span class="sd">            appropriate. Simply because lazy attributes are much</span>
<span class="sd">            faster than any method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Rings(); C</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: C.all_super_categories()</span>
<span class="sd">            [Category of rings, Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>

<span class="sd">            sage: C.all_super_categories(proper = True)</span>
<span class="sd">            [Category of rngs, Category of semirings, ...</span>
<span class="sd">             Category of monoids, ...</span>
<span class="sd">             Category of commutative additive groups, ...</span>
<span class="sd">             Category of sets, Category of sets with partial maps,</span>
<span class="sd">             Category of objects]</span>

<span class="sd">            sage: Sets().all_super_categories()</span>
<span class="sd">            [Category of sets, Category of sets with partial maps, Category of objects]</span>
<span class="sd">            sage: Sets().all_super_categories(proper=True)</span>
<span class="sd">            [Category of sets with partial maps, Category of objects]</span>
<span class="sd">            sage: Sets().all_super_categories() is Sets()._all_super_categories</span>
<span class="sd">            True</span>
<span class="sd">            sage: Sets().all_super_categories(proper=True) is Sets()._all_super_categories_proper</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">proper</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories_proper</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The immediate super categories of this category.</span>

<span class="sd">        This lazy attribute caches the result of the mandatory method</span>
<span class="sd">        :meth:`super_categories` for speed. It also does some mangling</span>
<span class="sd">        (flattening join categories, sorting, ...).</span>

<span class="sd">        Whenever speed matters, developers are advised to use this</span>
<span class="sd">        lazy attribute rather than calling :meth:`super_categories`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This attribute is likely to eventually become a tuple.</span>
<span class="sd">            When this happens, we might as well use :meth:`Category._sort`,</span>
<span class="sd">            if not :meth:`Category._sort_uniq`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._super_categories</span>
<span class="sd">            [Category of rngs, Category of semirings]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_flatten_categories</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">(),</span> <span class="n">JoinCategory</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">category_sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">_super_categories_for_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The super categories of this category used for building classes.</span>

<span class="sd">        This is a close variant of :meth:`_super_categories` used for</span>
<span class="sd">        constructing the list of the bases for :meth:`parent_class`,</span>
<span class="sd">        :meth:`element_class`, and friends. The purpose is ensure that</span>
<span class="sd">        Python will find a proper Method Resolution Order for those</span>
<span class="sd">        classes. For background, see :mod:`sage.misc.c3_controlled`.</span>

<span class="sd">        .. SEEALSO:: :meth:`_cmp_key`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This attribute is calculated as a by-product of computing</span>
<span class="sd">            :meth:`_all_super_categories`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Rings()._super_categories_for_classes</span>
<span class="sd">            [Category of rngs, Category of semirings]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories_for_classes</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Methods handling of full subcategories</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">additional_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``self`` defines additional structure.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - ``self`` if ``self`` defines additional structure and</span>
<span class="sd">          ``None`` otherwise. This default implementation returns</span>
<span class="sd">          ``self``.</span>

<span class="sd">        A category `C` *defines additional structure* if `C`-morphisms</span>
<span class="sd">        shall preserve more structure (e.g. operations) than that</span>
<span class="sd">        specified by the super categories of `C`. For example, the</span>
<span class="sd">        category of magmas defines additional structure, namely the</span>
<span class="sd">        operation `*` that shall be preserved by magma morphisms. On</span>
<span class="sd">        the other hand the category of rings does not define additional</span>
<span class="sd">        structure: a function between two rings that is both a unital</span>
<span class="sd">        magma morphism and a unital additive magma morphism is</span>
<span class="sd">        automatically a ring morphism.</span>

<span class="sd">        Formally speaking `C` *defines additional structure*, if `C`</span>
<span class="sd">        is *not* a full subcategory of the join of its super</span>
<span class="sd">        categories: the morphisms need to preserve more structure, and</span>
<span class="sd">        thus the homsets are smaller.</span>

<span class="sd">        By default, a category is considered as defining additional</span>
<span class="sd">        structure, unless it is a :ref:`category with axiom</span>
<span class="sd">        &lt;category-primer-axioms&gt;`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Here are some typical structure categories, with the</span>
<span class="sd">        additional structure they define::</span>

<span class="sd">            sage: Sets().additional_structure()</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Magmas().additional_structure()         # `*`</span>
<span class="sd">            Category of magmas</span>
<span class="sd">            sage: AdditiveMagmas().additional_structure() # `+`</span>
<span class="sd">            Category of additive magmas</span>
<span class="sd">            sage: LeftModules(ZZ).additional_structure()  # left multiplication by scalar</span>
<span class="sd">            Category of left modules over Integer Ring</span>
<span class="sd">            sage: Coalgebras(QQ).additional_structure()   # coproduct</span>
<span class="sd">            Category of coalgebras over Rational Field</span>
<span class="sd">            sage: Crystals().additional_structure()       # crystal operators</span>
<span class="sd">            Category of crystals</span>

<span class="sd">        On the other hand, the category of semigroups is not a</span>
<span class="sd">        structure category, since its operation `+` is already defined</span>
<span class="sd">        by the category of magmas::</span>

<span class="sd">            sage: Semigroups().additional_structure()</span>

<span class="sd">        Most :ref:`categories with axiom &lt;category-primer-axioms&gt;`</span>
<span class="sd">        don&#39;t define additional structure::</span>

<span class="sd">            sage: Sets().Finite().additional_structure()</span>
<span class="sd">            sage: Rings().Commutative().additional_structure()</span>
<span class="sd">            sage: Modules(QQ).FiniteDimensional().additional_structure()</span>
<span class="sd">            sage: from sage.categories.magmatic_algebras import MagmaticAlgebras</span>
<span class="sd">            sage: MagmaticAlgebras(QQ).Unital().additional_structure()</span>

<span class="sd">        As of Sage 6.4, the only exceptions are the category of unital</span>
<span class="sd">        magmas or the category of unital additive magmas (both define</span>
<span class="sd">        a unit which shall be preserved by morphisms)::</span>

<span class="sd">            sage: Magmas().Unital().additional_structure()</span>
<span class="sd">            Category of unital magmas</span>
<span class="sd">            sage: AdditiveMagmas().AdditiveUnital().additional_structure()</span>
<span class="sd">            Category of additive unital additive magmas</span>

<span class="sd">        Similarly, :ref:`functorial construction categories</span>
<span class="sd">        &lt;category-primer-functorial-constructions&gt;` don&#39;t define</span>
<span class="sd">        additional structure, unless the construction is actually</span>
<span class="sd">        defined by their base category. For example, the category of</span>
<span class="sd">        graded modules defines a grading which shall be preserved by</span>
<span class="sd">        morphisms::</span>

<span class="sd">            sage: Modules(ZZ).Graded().additional_structure()</span>
<span class="sd">            Category of graded modules over Integer Ring</span>

<span class="sd">        On the other hand, the category of graded algebras does not</span>
<span class="sd">        define additional structure; indeed an algebra morphism which</span>
<span class="sd">        is also a module morphism is a graded algebra morphism::</span>

<span class="sd">            sage: Algebras(ZZ).Graded().additional_structure()</span>

<span class="sd">        Similarly, morphisms are requested to preserve the structure</span>
<span class="sd">        given by the following constructions::</span>

<span class="sd">            sage: Sets().Quotients().additional_structure()</span>
<span class="sd">            Category of quotients of sets</span>
<span class="sd">            sage: Sets().CartesianProducts().additional_structure()</span>
<span class="sd">            Category of Cartesian products of sets</span>
<span class="sd">            sage: Modules(QQ).TensorProducts().additional_structure()</span>

<span class="sd">        This might change, as we are lacking enough data points to</span>
<span class="sd">        guarantee that this was the correct design decision.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            In some cases a category defines additional structure,</span>
<span class="sd">            where the structure can be useful to manipulate morphisms</span>
<span class="sd">            but where, in most use cases, we don&#39;t want the morphisms</span>
<span class="sd">            to necessarily preserve it. For example, in the context of</span>
<span class="sd">            finite dimensional vector spaces, having a distinguished</span>
<span class="sd">            basis allows for representing morphisms by matrices; yet</span>
<span class="sd">            considering only morphisms that preserve that</span>
<span class="sd">            distinguished basis would be boring.</span>

<span class="sd">            In such cases, we might want to eventually have two</span>
<span class="sd">            categories, one where the additional structure is</span>
<span class="sd">            preserved, and one where it&#39;s not necessarily preserved</span>
<span class="sd">            (we would need to find an idiom for this).</span>

<span class="sd">            At this point, a choice is to be made each time, according</span>
<span class="sd">            to the main use cases. Some of those choices are yet to be</span>
<span class="sd">            settled. For example, should by default:</span>

<span class="sd">            - an euclidean domain morphism preserve euclidean</span>
<span class="sd">              division? ::</span>

<span class="sd">                  sage: EuclideanDomains().additional_structure()</span>
<span class="sd">                  Category of euclidean domains</span>

<span class="sd">            - an enumerated set morphism preserve the distinguished</span>
<span class="sd">              enumeration? ::</span>

<span class="sd">                  sage: EnumeratedSets().additional_structure()</span>

<span class="sd">            - a module with basis morphism preserve the distinguished</span>
<span class="sd">              basis? ::</span>

<span class="sd">                  sage: Modules(QQ).WithBasis().additional_structure()</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            This method together with the methods overloading it</span>
<span class="sd">            provide the basic data to determine, for a given category,</span>
<span class="sd">            the super categories that define some structure (see</span>
<span class="sd">            :meth:`structure`), and to test whether a category is a</span>
<span class="sd">            full subcategory of some other category (see</span>
<span class="sd">            :meth:`is_full_subcategory`). For example, the category of</span>
<span class="sd">            Coxeter groups is not full subcategory of the category of</span>
<span class="sd">            groups since morphisms need to preserve the distinguished</span>
<span class="sd">            generators::</span>

<span class="sd">                sage: CoxeterGroups().is_full_subcategory(Groups())</span>
<span class="sd">                False</span>

<span class="sd">            The support for modeling full subcategories has been</span>
<span class="sd">            introduced in :issue:`16340`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the structure ``self`` is endowed with.</span>

<span class="sd">        This method returns the structure that morphisms in this</span>
<span class="sd">        category shall be preserving. For example, it tells that a</span>
<span class="sd">        ring is a set endowed with a structure of both a unital magma</span>
<span class="sd">        and an additive unital magma which satisfies some further</span>
<span class="sd">        axioms. In other words, a ring morphism is a function that</span>
<span class="sd">        preserves the unital magma and additive unital magma</span>
<span class="sd">        structure.</span>

<span class="sd">        In practice, this returns the collection of all the super</span>
<span class="sd">        categories of ``self`` that define some additional structure,</span>
<span class="sd">        as a frozen set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Objects().structure()</span>
<span class="sd">            frozenset()</span>

<span class="sd">            sage: def structure(C):</span>
<span class="sd">            ....:     return Category._sort(C.structure())</span>

<span class="sd">            sage: structure(Sets())</span>
<span class="sd">            (Category of sets, Category of sets with partial maps)</span>
<span class="sd">            sage: structure(Magmas())</span>
<span class="sd">            (Category of magmas, Category of sets, Category of sets with partial maps)</span>

<span class="sd">        In the following example, we only list the smallest structure</span>
<span class="sd">        categories to get a more readable output::</span>

<span class="sd">            sage: def structure(C):</span>
<span class="sd">            ....:     return Category._sort_uniq(C.structure())</span>

<span class="sd">            sage: structure(Magmas())</span>
<span class="sd">            (Category of magmas,)</span>
<span class="sd">            sage: structure(Rings())</span>
<span class="sd">            (Category of unital magmas, Category of additive unital additive magmas)</span>
<span class="sd">            sage: structure(Fields())</span>
<span class="sd">            (Category of euclidean domains,)</span>
<span class="sd">            sage: structure(Algebras(QQ))</span>
<span class="sd">            (Category of unital magmas,</span>
<span class="sd">             Category of right modules over Rational Field,</span>
<span class="sd">             Category of left modules over Rational Field)</span>
<span class="sd">            sage: structure(HopfAlgebras(QQ).Graded().WithBasis().Connected())</span>
<span class="sd">            (Category of Hopf algebras over Rational Field,</span>
<span class="sd">             Category of graded modules over Rational Field)</span>

<span class="sd">        This method is used in :meth:`is_full_subcategory` for</span>
<span class="sd">        deciding whether a category is a full subcategory of some</span>
<span class="sd">        other category, and for documentation purposes. It is computed</span>
<span class="sd">        recursively from the result of :meth:`additional_structure`</span>
<span class="sd">        on the super categories of ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">D</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span> <span class="k">for</span> <span class="n">D</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">structure</span><span class="p">()}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_full_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``self`` is a full subcategory of ``other``.</span>

<span class="sd">        A subcategory `B` of a category `A` is a *full subcategory* if</span>
<span class="sd">        any `A`-morphism between two objects of `B` is also a</span>
<span class="sd">        `B`-morphism (the reciprocal always holds: any `B`-morphism</span>
<span class="sd">        between two objects of `B` is an `A`-morphism).</span>

<span class="sd">        This is computed by testing whether ``self`` is a subcategory</span>
<span class="sd">        of ``other`` and whether they have the same structure, as</span>
<span class="sd">        determined by :meth:`structure` from the</span>
<span class="sd">        result of :meth:`additional_structure` on the super</span>
<span class="sd">        categories.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            A positive answer is guaranteed to be mathematically</span>
<span class="sd">            correct. A negative answer may mean that Sage has not been</span>
<span class="sd">            taught enough information (or can not yet within the</span>
<span class="sd">            current model) to derive this information. See</span>
<span class="sd">            :meth:`full_super_categories` for a discussion.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`is_subcategory`</span>
<span class="sd">            - :meth:`full_super_categories`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Magmas().Associative().is_full_subcategory(Magmas())</span>
<span class="sd">            True</span>
<span class="sd">            sage: Magmas().Unital().is_full_subcategory(Magmas())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Rings().is_full_subcategory(Magmas().Unital() &amp; AdditiveMagmas().AdditiveUnital())</span>
<span class="sd">            True</span>

<span class="sd">        Here are two typical examples of false negatives::</span>

<span class="sd">            sage: Groups().is_full_subcategory(Semigroups())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Groups().is_full_subcategory(Semigroups()) # todo: not implemented</span>
<span class="sd">            True</span>
<span class="sd">            sage: Fields().is_full_subcategory(Rings())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Fields().is_full_subcategory(Rings())      # todo: not implemented</span>
<span class="sd">            True</span>

<span class="sd">        .. TODO::</span>

<span class="sd">            The latter is a consequence of :class:`EuclideanDomains`</span>
<span class="sd">            currently being a structure category. Is this what we</span>
<span class="sd">            want? ::</span>

<span class="sd">                sage: EuclideanDomains().is_full_subcategory(Rings())</span>
<span class="sd">                False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">structure</span><span class="p">())</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">full_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the *immediate* full super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`super_categories`</span>
<span class="sd">            - :meth:`is_full_subcategory`</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            The current implementation selects the full subcategories</span>
<span class="sd">            among the immediate super categories of ``self``. This</span>
<span class="sd">            assumes that, if `C\subset B\subset A` is a chain of</span>
<span class="sd">            categories and `C` is a full subcategory of `A`, then `C`</span>
<span class="sd">            is a full subcategory of `B` and `B` is a full subcategory</span>
<span class="sd">            of `A`.</span>

<span class="sd">            This assumption is guaranteed to hold with the current</span>
<span class="sd">            model and implementation of full subcategories in</span>
<span class="sd">            Sage. However, mathematically speaking, this is too</span>
<span class="sd">            restrictive. This indeed prevents the complete modelling</span>
<span class="sd">            of situations where any `A` morphism between elements of</span>
<span class="sd">            `C` automatically preserves the `B` structure. See below</span>
<span class="sd">            for an example.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A semigroup morphism between two finite semigroups is a finite</span>
<span class="sd">        semigroup morphism::</span>

<span class="sd">            sage: Semigroups().Finite().full_super_categories()</span>
<span class="sd">            [Category of semigroups]</span>

<span class="sd">        On the other hand, a semigroup morphism between two monoids is</span>
<span class="sd">        not necessarily a monoid morphism (which must map the unit to</span>
<span class="sd">        the unit)::</span>

<span class="sd">            sage: Monoids().super_categories()</span>
<span class="sd">            [Category of semigroups, Category of unital magmas]</span>
<span class="sd">            sage: Monoids().full_super_categories()</span>
<span class="sd">            [Category of unital magmas]</span>

<span class="sd">        Any semigroup morphism between two groups is automatically a</span>
<span class="sd">        monoid morphism (in a group the unit is the unique idempotent,</span>
<span class="sd">        so it has to be mapped to the unit). Yet, due to the</span>
<span class="sd">        limitation of the model advertised above, Sage currently cannot</span>
<span class="sd">        be taught that the category of groups is a full subcategory of</span>
<span class="sd">        the category of semigroups::</span>

<span class="sd">            sage: Groups().full_super_categories()     # todo: not implemented</span>
<span class="sd">            [Category of monoids, Category of semigroups, Category of inverse unital magmas]</span>
<span class="sd">            sage: Groups().full_super_categories()</span>
<span class="sd">            [Category of monoids, Category of inverse unital magmas]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">C</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">C</span><span class="p">)]</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Test methods</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">_test_category_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the category graph matches with Python&#39;s method resolution order</span>

<span class="sd">        .. note::</span>

<span class="sd">            By :issue:`11943`, the list of categories returned by</span>
<span class="sd">            :meth:`all_super_categories` is supposed to match with the</span>
<span class="sd">            method resolution order of the parent and element</span>
<span class="sd">            classes. This method checks this.</span>

<span class="sd">        .. TODO:: currently, this won&#39;t work for hom categories.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = HopfAlgebrasWithBasis(QQ)</span>
<span class="sd">            sage: C.parent_class.mro() == [X.parent_class for X in C._all_super_categories] + [object]</span>
<span class="sd">            True</span>
<span class="sd">            sage: C.element_class.mro() == [X.element_class for X in C._all_super_categories] + [object]</span>
<span class="sd">            True</span>
<span class="sd">            sage: TestSuite(C).run()    # indirect doctest</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="n">mro</span><span class="p">(),</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">parent_class</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">object</span><span class="p">])</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">mro</span><span class="p">(),</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">element_class</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">object</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_test_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run generic tests on this category</span>

<span class="sd">        .. SEEALSO:: :class:`TestSuite`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._test_category()</span>

<span class="sd">        Let us now write a couple broken categories::</span>

<span class="sd">            sage: class MyObjects(Category):</span>
<span class="sd">            ....:      pass</span>
<span class="sd">            sage: MyObjects()._test_category()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: &lt;abstract method super_categories at ...&gt;</span>

<span class="sd">            sage: class MyObjects(Category):</span>
<span class="sd">            ....:      def super_categories(self):</span>
<span class="sd">            ....:          return tuple()</span>
<span class="sd">            sage: MyObjects()._test_category()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AssertionError: Category of my objects.super_categories() should return a list</span>

<span class="sd">            sage: class MyObjects(Category):</span>
<span class="sd">            ....:      def super_categories(self):</span>
<span class="sd">            ....:          return []</span>
<span class="sd">            sage: MyObjects()._test_category()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AssertionError: Category of my objects is not a subcategory of Objects()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.categories.objects</span> <span class="kn">import</span> <span class="n">Objects</span>
        <span class="kn">from</span> <span class="nn">sage.categories.sets_cat</span> <span class="kn">import</span> <span class="n">Sets</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">(),</span> <span class="nb">list</span><span class="p">),</span>
                          <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.super_categories() should return a list&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Objects</span><span class="p">()),</span>
                          <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a subcategory of Objects()&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">):</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmp_key</span> <span class="o">&gt;</span> <span class="n">cat</span><span class="o">.</span><span class="n">_cmp_key</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">))</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">())))</span>  <span class="c1"># Not an obviously passing test with axioms</span>

        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories_proper</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">category</span><span class="p">):</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_super_categories</span><span class="p">()),</span>
                                  <span class="s2">&quot;Every full super category should be a super category&quot;</span>
                                  <span class="s2">&quot;of some immediate full super category&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Sets</span><span class="p">()):</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

    <span class="n">_cmp_key</span> <span class="o">=</span> <span class="n">_cmp_key</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Construction of the associated abstract classes for parents, elements, ...</span>
    <span class="c1">##########################################################################</span>

    <span class="k">def</span> <span class="nf">_make_named_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">picklable</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construction of the parent/element/... class of ``self``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``name`` -- a string; the name of the class as an attribute of</span>
<span class="sd">          ``self``. E.g. &quot;parent_class&quot;</span>
<span class="sd">        - ``method_provider`` -- a string; the name of an attribute of</span>
<span class="sd">          ``self`` that provides methods for the new class (in</span>
<span class="sd">          addition to those coming from the super categories).</span>
<span class="sd">          E.g. &quot;ParentMethods&quot;</span>
<span class="sd">        - ``cache`` -- a boolean or ``ignore_reduction`` (default: ``False``)</span>
<span class="sd">          (passed down to dynamic_class; for internal use only)</span>
<span class="sd">        - ``picklable`` -- a boolean (default: ``True``)</span>

<span class="sd">        ASSUMPTION:</span>

<span class="sd">        It is assumed that this method is only called from a lazy</span>
<span class="sd">        attribute whose name coincides with the given ``name``.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A dynamic class with bases given by the corresponding named</span>
<span class="sd">        classes of ``self``&#39;s super_categories, and methods taken from</span>
<span class="sd">        the class ``getattr(self,method_provider)``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            - In this default implementation, the reduction data of</span>
<span class="sd">              the named class makes it depend on ``self``. Since the</span>
<span class="sd">              result is going to be stored in a lazy attribute of</span>
<span class="sd">              ``self`` anyway, we may as well disable the caching in</span>
<span class="sd">              ``dynamic_class`` (hence the default value</span>
<span class="sd">              ``cache=False``).</span>

<span class="sd">            - :class:`CategoryWithParameters` overrides this method so</span>
<span class="sd">              that the same parent/element/... classes can be shared</span>
<span class="sd">              between closely related categories.</span>

<span class="sd">            - The bases of the named class may also contain the named</span>
<span class="sd">              classes of some indirect super categories, according to</span>
<span class="sd">              :meth:`_super_categories_for_classes`. This is to</span>
<span class="sd">              guarantee that Python will build consistent method</span>
<span class="sd">              resolution orders. For background, see</span>
<span class="sd">              :mod:`sage.misc.c3_controlled`.</span>

<span class="sd">        .. SEEALSO:: :meth:`CategoryWithParameters._make_named_class`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: PC = Rings()._make_named_class(&quot;parent_class&quot;, &quot;ParentMethods&quot;); PC</span>
<span class="sd">            &lt;class &#39;sage.categories.rings.Rings.parent_class&#39;&gt;</span>
<span class="sd">            sage: type(PC)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
<span class="sd">            sage: PC.__bases__</span>
<span class="sd">            (&lt;class &#39;sage.categories.rngs.Rngs.parent_class&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;sage.categories.semirings.Semirings.parent_class&#39;&gt;)</span>

<span class="sd">        Note that, by default, the result is not cached::</span>

<span class="sd">            sage: PC is Rings()._make_named_class(&quot;parent_class&quot;, &quot;ParentMethods&quot;)</span>
<span class="sd">            False</span>

<span class="sd">        Indeed this method is only meant to construct lazy attributes</span>
<span class="sd">        like ``parent_class`` which already handle this caching::</span>

<span class="sd">            sage: Rings().parent_class</span>
<span class="sd">            &lt;class &#39;sage.categories.rings.Rings.parent_class&#39;&gt;</span>

<span class="sd">        Reduction for pickling also assumes the existence of this lazy</span>
<span class="sd">        attribute::</span>

<span class="sd">            sage: PC._reduction</span>
<span class="sd">            (&lt;built-in function getattr&gt;, (Category of rings, &#39;parent_class&#39;))</span>
<span class="sd">            sage: loads(dumps(PC)) is Rings().parent_class</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: class A: pass</span>
<span class="sd">            sage: class BrokenCategory(Category):</span>
<span class="sd">            ....:     def super_categories(self): return []</span>
<span class="sd">            ....:     ParentMethods = 1</span>
<span class="sd">            ....:     class ElementMethods(A):</span>
<span class="sd">            ....:         pass</span>
<span class="sd">            ....:     class MorphismMethods():</span>
<span class="sd">            ....:         pass</span>
<span class="sd">            sage: C = BrokenCategory()</span>
<span class="sd">            sage: C._make_named_class(&quot;parent_class&quot;,   &quot;ParentMethods&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AssertionError: BrokenCategory.ParentMethods should be a class</span>
<span class="sd">            sage: C._make_named_class(&quot;element_class&quot;,  &quot;ElementMethods&quot;)</span>
<span class="sd">            doctest:...: UserWarning: BrokenCategory.ElementMethods should not have a super class</span>
<span class="sd">            &lt;class &#39;__main__.BrokenCategory.element_class&#39;&gt;</span>
<span class="sd">            sage: C._make_named_class(&quot;morphism_class&quot;, &quot;MorphismMethods&quot;)</span>
<span class="sd">            &lt;class &#39;__main__.BrokenCategory.morphism_class&#39;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DynamicMetaclass</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__base__</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">method_provider_cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method_provider_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the category provides no XXXMethods class,</span>
            <span class="c1"># point to the documentation of the category itself</span>
            <span class="n">doccls</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, check XXXMethods</span>
            <span class="k">assert</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">method_provider_cls</span><span class="p">),</span> \
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> should be a class&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">)</span>
            <span class="n">mro</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmro</span><span class="p">(</span><span class="n">method_provider_cls</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mro</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mro</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">mro</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">object</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> should not have a super class&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">))</span>
            <span class="c1"># and point the documentation to it</span>
            <span class="n">doccls</span> <span class="o">=</span> <span class="n">method_provider_cls</span>
        <span class="k">if</span> <span class="n">picklable</span><span class="p">:</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">dynamic_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span>
                             <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories_for_classes</span><span class="p">),</span>
                             <span class="n">method_provider_cls</span><span class="p">,</span> <span class="n">prepend_cls_bases</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">doccls</span><span class="o">=</span><span class="n">doccls</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">subcategory_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A common superclass for all subcategories of this category (including this one).</span>

<span class="sd">        This class derives from ``D.subcategory_class`` for each super</span>
<span class="sd">        category `D` of ``self``, and includes all the methods from</span>
<span class="sd">        the nested class ``self.SubcategoryMethods``, if it exists.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :issue:`12895`</span>
<span class="sd">            - :meth:`parent_class`</span>
<span class="sd">            - :meth:`element_class`</span>
<span class="sd">            - :meth:`_make_named_class`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cls = Rings().subcategory_class; cls</span>
<span class="sd">            &lt;class &#39;sage.categories.rings.Rings.subcategory_class&#39;&gt;</span>
<span class="sd">            sage: type(cls)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>

<span class="sd">        ``Rings()`` is an instance of this class, as well as all its subcategories::</span>

<span class="sd">            sage: isinstance(Rings(), cls)</span>
<span class="sd">            True</span>
<span class="sd">            sage: isinstance(AlgebrasWithBasis(QQ), cls)</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: cls = Algebras(QQ).subcategory_class; cls</span>
<span class="sd">            &lt;class &#39;sage.categories.algebras.Algebras.subcategory_class&#39;&gt;</span>
<span class="sd">            sage: type(cls)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">&#39;subcategory_class&#39;</span><span class="p">,</span> <span class="s1">&#39;SubcategoryMethods&#39;</span><span class="p">,</span>
                                      <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">picklable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">parent_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A common super class for all parents in this category (and its</span>
<span class="sd">        subcategories).</span>

<span class="sd">        This class contains the methods defined in the nested class</span>
<span class="sd">        ``self.ParentMethods`` (if it exists), and has as bases the</span>
<span class="sd">        parent classes of the super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`element_class`, :meth:`morphism_class`</span>
<span class="sd">            - :class:`Category` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ).parent_class; C</span>
<span class="sd">            &lt;class &#39;sage.categories.algebras.Algebras.parent_class&#39;&gt;</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>

<span class="sd">        By :issue:`11935`, some categories share their parent</span>
<span class="sd">        classes. For example, the parent class of an algebra only</span>
<span class="sd">        depends on the category of the base ring. A typical example is</span>
<span class="sd">        the category of algebras over a finite field versus algebras</span>
<span class="sd">        over a non-field::</span>

<span class="sd">            sage: Algebras(GF(7)).parent_class is Algebras(GF(5)).parent_class</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ).parent_class is Algebras(ZZ).parent_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Algebras(ZZ[&#39;t&#39;]).parent_class is Algebras(ZZ[&#39;t&#39;,&#39;x&#39;]).parent_class</span>
<span class="sd">            True</span>

<span class="sd">        See :class:`CategoryWithParameters` for an abstract base class for</span>
<span class="sd">        categories that depend on parameters, even though the parent</span>
<span class="sd">        and element classes only depend on the parent or element</span>
<span class="sd">        classes of its super categories. It is used in</span>
<span class="sd">        :class:`~sage.categories.bimodules.Bimodules`,</span>
<span class="sd">        :class:`~sage.categories.category_types.Category_over_base` and</span>
<span class="sd">        :class:`sage.categories.category.JoinCategory`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">&#39;parent_class&#39;</span><span class="p">,</span> <span class="s1">&#39;ParentMethods&#39;</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A common super class for all elements of parents in this category</span>
<span class="sd">        (and its subcategories).</span>

<span class="sd">        This class contains the methods defined in the nested class</span>
<span class="sd">        ``self.ElementMethods`` (if it exists), and has as bases the</span>
<span class="sd">        element classes of the super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`parent_class`, :meth:`morphism_class`</span>
<span class="sd">            - :class:`Category` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ).element_class; C</span>
<span class="sd">            &lt;class &#39;sage.categories.algebras.Algebras.element_class&#39;&gt;</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>

<span class="sd">        By :issue:`11935`, some categories share their element</span>
<span class="sd">        classes. For example, the element class of an algebra only</span>
<span class="sd">        depends on the category of the base. A typical example is the</span>
<span class="sd">        category of algebras over a field versus algebras over a</span>
<span class="sd">        non-field::</span>

<span class="sd">            sage: Algebras(GF(5)).element_class is Algebras(GF(3)).element_class</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ).element_class is Algebras(ZZ).element_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Algebras(ZZ[&#39;t&#39;]).element_class is Algebras(ZZ[&#39;t&#39;,&#39;x&#39;]).element_class</span>
<span class="sd">            True</span>

<span class="sd">        These classes are constructed with ``__slots__ = ()``, so</span>
<span class="sd">        instances may not have a ``__dict__``::</span>

<span class="sd">            sage: E = FiniteEnumeratedSets().element_class</span>
<span class="sd">            sage: E.__dictoffset__</span>
<span class="sd">            0</span>

<span class="sd">        .. SEEALSO:: :meth:`parent_class`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">&#39;element_class&#39;</span><span class="p">,</span> <span class="s1">&#39;ElementMethods&#39;</span><span class="p">)</span>

    <span class="nd">@lazy_attribute</span>
    <span class="k">def</span> <span class="nf">morphism_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A common super class for all morphisms between parents in this</span>
<span class="sd">        category (and its subcategories).</span>

<span class="sd">        This class contains the methods defined in the nested class</span>
<span class="sd">        ``self.MorphismMethods`` (if it exists), and has as bases the</span>
<span class="sd">        morphism classes of the super categories of ``self``.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`parent_class`, :meth:`element_class`</span>
<span class="sd">            - :class:`Category` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Algebras(QQ).morphism_class; C</span>
<span class="sd">            &lt;class &#39;sage.categories.algebras.Algebras.morphism_class&#39;&gt;</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s1">&#39;morphism_class&#39;</span><span class="p">,</span> <span class="s1">&#39;MorphismMethods&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">required_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the methods that are required and optional for parents</span>
<span class="sd">        in this category and their elements.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Algebras(QQ).required_methods()</span>
<span class="sd">            {&#39;element&#39;: {&#39;optional&#39;: [&#39;_add_&#39;, &#39;_mul_&#39;], &#39;required&#39;: [&#39;__bool__&#39;]},</span>
<span class="sd">             &#39;parent&#39;: {&#39;optional&#39;: [&#39;algebra_generators&#39;], &#39;required&#39;: [&#39;__contains__&#39;]}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">),</span>
                <span class="s2">&quot;element&quot;</span><span class="p">:</span> <span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">)}</span>

    <span class="c1"># Operations on the lattice of categories</span>
    <span class="k">def</span> <span class="nf">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if self is naturally embedded as a subcategory of c.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: AbGrps = CommutativeAdditiveGroups()</span>
<span class="sd">            sage: Rings().is_subcategory(AbGrps)</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbGrps.is_subcategory(Rings())</span>
<span class="sd">            False</span>

<span class="sd">        The ``is_subcategory`` function takes into account the</span>
<span class="sd">        base.</span>

<span class="sd">        ::</span>

<span class="sd">            sage: M3 = VectorSpaces(FiniteField(3))</span>
<span class="sd">            sage: M9 = VectorSpaces(FiniteField(9, &#39;a&#39;))                                # needs sage.rings.finite_rings</span>
<span class="sd">            sage: M3.is_subcategory(M9)                                                 # needs sage.rings.finite_rings</span>
<span class="sd">            False</span>

<span class="sd">        Join categories are properly handled::</span>

<span class="sd">            sage: CatJ = Category.join((CommutativeAdditiveGroups(), Semigroups()))</span>
<span class="sd">            sage: Rings().is_subcategory(CatJ)</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: V3 = VectorSpaces(FiniteField(3))</span>
<span class="sd">            sage: POSet = PartiallyOrderedSets()</span>
<span class="sd">            sage: PoV3 = Category.join((V3, POSet))</span>
<span class="sd">            sage: A3 = AlgebrasWithBasis(FiniteField(3))</span>
<span class="sd">            sage: PoA3 = Category.join((A3, POSet))</span>
<span class="sd">            sage: PoA3.is_subcategory(PoV3)</span>
<span class="sd">            True</span>
<span class="sd">            sage: PoV3.is_subcategory(PoV3)</span>
<span class="sd">            True</span>
<span class="sd">            sage: PoV3.is_subcategory(PoA3)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">subcat_hook</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subcat_hook</span> <span class="ow">is</span> <span class="n">Unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_of_super_categories</span>
        <span class="k">return</span> <span class="n">subcat_hook</span>

    <span class="k">def</span> <span class="nf">or_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``category`` or ``self`` if ``category`` is ``None``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``category`` -- a sub category of ``self``, tuple/list thereof,</span>
<span class="sd">          or ``None``</span>
<span class="sd">        - ``join`` -- a boolean (default: ``False``)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a category</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Monoids().or_subcategory(Groups())</span>
<span class="sd">            Category of groups</span>
<span class="sd">            sage: Monoids().or_subcategory(None)</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        If category is a list/tuple, then a join category is returned::</span>

<span class="sd">            sage: Monoids().or_subcategory((CommutativeAdditiveMonoids(), Groups()))</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>

<span class="sd">        If ``join`` is ``False``, an error if raised if category is not a</span>
<span class="sd">        subcategory of ``self``::</span>

<span class="sd">            sage: Monoids().or_subcategory(EnumeratedSets())</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: Subcategory of `Category of monoids` required;</span>
<span class="sd">            got `Category of enumerated sets`</span>

<span class="sd">        Otherwise, the two categories are joined together::</span>

<span class="sd">            sage: Monoids().or_subcategory(EnumeratedSets(), join=True)</span>
<span class="sd">            Category of enumerated monoids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">category</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Subcategory of `</span><span class="si">{}</span><span class="s2">` required; got `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">category</span>

    <span class="k">def</span> <span class="nf">_is_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as is_subcategory, but c may also be the class of a</span>
<span class="sd">        category instead of a category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Fields()._is_subclass(Rings)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ)._is_subclass(Modules)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Algebras(QQ)._is_subclass(ModulesWithBasis)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Category</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Category</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_super_categories</span><span class="p">)</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_meet_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the largest common subcategory of self and other:</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Monoids()._meet_(Monoids())</span>
<span class="sd">            Category of monoids</span>
<span class="sd">            sage: Rings()._meet_(Rings())</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: Rings()._meet_(Monoids())</span>
<span class="sd">            Category of monoids</span>
<span class="sd">            sage: Monoids()._meet_(Rings())</span>
<span class="sd">            Category of monoids</span>

<span class="sd">            sage: VectorSpaces(QQ)._meet_(Modules(ZZ))</span>
<span class="sd">            Category of commutative additive groups</span>
<span class="sd">            sage: Algebras(ZZ)._meet_(Algebras(QQ))</span>
<span class="sd">            Category of rings</span>
<span class="sd">            sage: Groups()._meet_(Rings())</span>
<span class="sd">            Category of monoids</span>
<span class="sd">            sage: Algebras(QQ)._meet_(Category.join([Fields(), ModulesWithBasis(QQ)]))</span>
<span class="sd">            Join of Category of rings and Category of vector spaces over Rational Field</span>

<span class="sd">        Note: abstractly, the category poset is a distributive</span>
<span class="sd">        lattice, so this is well defined; however, the subset of those</span>
<span class="sd">        categories actually implemented is not: we need to also</span>
<span class="sd">        include their join-categories.</span>

<span class="sd">        For example, the category of rings is *not* the join of the</span>
<span class="sd">        category of abelian groups and that of semi groups, just a</span>
<span class="sd">        subcategory of their join, since rings further require</span>
<span class="sd">        distributivity.</span>

<span class="sd">        For the meet computation, there may be several lowest common</span>
<span class="sd">        sub categories of self and other, in which case, we need to</span>
<span class="sd">        take the join of them all.</span>

<span class="sd">        FIXME:</span>

<span class="sd">        - If A is a subcategory of B, A has *more* structure than B,</span>
<span class="sd">          but then *less* objects in there. We should choose an</span>
<span class="sd">          appropriate convention for A&lt;B. Using subcategory calls</span>
<span class="sd">          for A&lt;B, but the current meet and join call for A&gt;B.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>  <span class="c1"># useful? fast pathway</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Useful fast pathway; try:</span>
            <span class="c1"># %time L = EllipticCurve(&#39;960d1&#39;).prove_BSD()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meet_</span><span class="p">(</span><span class="n">sup</span><span class="p">)</span> <span class="k">for</span> <span class="n">sup</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">meet</span><span class="p">(</span><span class="n">categories</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the meet of a list of categories</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``categories`` - a non empty list (or iterable) of categories</span>

<span class="sd">        .. SEEALSO:: :meth:`__or__` for a shortcut</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category.meet([Algebras(ZZ), Algebras(QQ), Groups()])</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        That meet of an empty list should be a category which is a</span>
<span class="sd">        subcategory of all categories, which does not make practical sense::</span>

<span class="sd">            sage: Category.meet([])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: The meet of an empty list of categories is not implemented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">categories</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The meet of an empty list of categories is not implemented&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">categories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_meet_</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the axioms known to be satisfied by all the objects of ``self``.</span>

<span class="sd">        Technically, this is the set of all the axioms ``A`` such that, if</span>
<span class="sd">        ``Cs`` is the category defining ``A``, then ``self`` is a subcategory</span>
<span class="sd">        of ``Cs().A()``. Any additional axiom ``A`` would yield a strict</span>
<span class="sd">        subcategory of ``self``, at the very least ``self &amp; Cs().A()`` where</span>
<span class="sd">        ``Cs`` is the category defining ``A``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Monoids().axioms()</span>
<span class="sd">            frozenset({&#39;Associative&#39;, &#39;Unital&#39;})</span>
<span class="sd">            sage: (EnumeratedSets().Infinite() &amp; Sets().Facade()).axioms()</span>
<span class="sd">            frozenset({&#39;Enumerated&#39;, &#39;Facade&#39;, &#39;Infinite&#39;})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">axiom</span>
                         <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span>
                         <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="n">category</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_with_axiom_as_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of categories whose join is ``self._with_axiom()``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``axiom`` -- a string, the name of an axiom</span>

<span class="sd">        This is a lazy version of :meth:`_with_axiom` which is used to</span>
<span class="sd">        avoid recursion loops during join calculations.</span>

<span class="sd">        .. NOTE:: The order in the result is irrelevant.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._with_axiom_as_tuple(&#39;Finite&#39;)</span>
<span class="sd">            (Category of finite sets,)</span>
<span class="sd">            sage: Magmas()._with_axiom_as_tuple(&#39;Finite&#39;)</span>
<span class="sd">            (Category of magmas, Category of finite sets)</span>
<span class="sd">            sage: Rings().Division()._with_axiom_as_tuple(&#39;Finite&#39;)</span>
<span class="sd">            (Category of division rings,</span>
<span class="sd">             Category of finite monoids,</span>
<span class="sd">             Category of commutative magmas,</span>
<span class="sd">             Category of finite additive groups)</span>
<span class="sd">            sage: HopfAlgebras(QQ)._with_axiom_as_tuple(&#39;FiniteDimensional&#39;)</span>
<span class="sd">            (Category of Hopf algebras over Rational Field,</span>
<span class="sd">             Category of finite dimensional vector spaces over Rational Field)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">axiom_attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axiom_attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the axiom is not defined for this category, ignore it</span>
            <span class="c1"># This uses the following invariant: the categories for</span>
            <span class="c1"># which a given axiom is defined form a lower set</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="c1"># self implements this axiom</span>
            <span class="kn">from</span> <span class="nn">.category_with_axiom</span> <span class="kn">import</span> <span class="n">CategoryWithAxiom</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">axiom_attribute</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">axiom_attribute</span><span class="p">,</span> <span class="n">CategoryWithAxiom</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">axiom_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>
            <span class="n">warn</span><span class="p">((</span><span class="s2">&quot;Expecting </span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2"> to be a subclass of CategoryWithAxiom to&quot;</span>
                  <span class="s2">&quot; implement a category with axiom; got </span><span class="si">{}</span><span class="s2">; ignoring&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                      <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="n">axiom_attribute</span><span class="p">))</span>

        <span class="c1"># self does not implement this axiom</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cat</span>
                                  <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span>
                                  <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">category</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="n">axiom</span><span class="p">))</span>
        <span class="n">hook</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span> <span class="o">+</span> <span class="s2">&quot;_extra_super_categories&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">hook</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hook</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">_sort_uniq</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_with_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the subcategory of the objects of ``self`` satisfying</span>
<span class="sd">        the given ``axiom``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``axiom`` -- a string, the name of an axiom</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._with_axiom(&quot;Finite&quot;)</span>
<span class="sd">            Category of finite sets</span>

<span class="sd">            sage: type(Magmas().Finite().Commutative())</span>
<span class="sd">            &lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="sd">            sage: Magmas().Finite().Commutative().super_categories()</span>
<span class="sd">            [Category of commutative magmas, Category of finite sets]</span>
<span class="sd">            sage: C = Algebras(QQ).WithBasis().Commutative()</span>
<span class="sd">            sage: C is Algebras(QQ).Commutative().WithBasis()</span>
<span class="sd">            True</span>

<span class="sd">        When ``axiom`` is not defined for ``self``, ``self`` is returned::</span>

<span class="sd">            sage: Sets()._with_axiom(&quot;Associative&quot;)</span>
<span class="sd">            Category of sets</span>

<span class="sd">        .. WARNING:: This may be changed in the future to raising an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="n">axiom</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_with_axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axioms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the subcategory of the objects of ``self`` satisfying</span>
<span class="sd">        the given ``axioms``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``axioms`` -- a list of strings, the names of the axioms</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._with_axioms([&quot;Finite&quot;])</span>
<span class="sd">            Category of finite sets</span>
<span class="sd">            sage: Sets()._with_axioms([&quot;Infinite&quot;])</span>
<span class="sd">            Category of infinite sets</span>
<span class="sd">            sage: FiniteSets()._with_axioms([&quot;Finite&quot;])</span>
<span class="sd">            Category of finite sets</span>

<span class="sd">        Axioms that are not defined for the ``self`` are ignored::</span>

<span class="sd">            sage: Sets()._with_axioms([&quot;FooBar&quot;])</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Magmas()._with_axioms([&quot;FooBar&quot;, &quot;Unital&quot;])</span>
<span class="sd">            Category of unital magmas</span>

<span class="sd">        Note that adding several axioms at once can do more than</span>
<span class="sd">        adding them one by one. This is because the availability of an</span>
<span class="sd">        axiom may depend on another axiom. For example, for</span>
<span class="sd">        semigroups, the ``Inverse`` axiom is meaningless unless there</span>
<span class="sd">        is a unit::</span>

<span class="sd">            sage: Semigroups().Inverse()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AttributeError: &#39;Semigroups_with_category&#39; object has no attribute &#39;Inverse&#39;...</span>
<span class="sd">            sage: Semigroups()._with_axioms([&quot;Inverse&quot;])</span>
<span class="sd">            Category of semigroups</span>

<span class="sd">        So one needs to first add the ``Unital`` axiom, and then the</span>
<span class="sd">        ``Inverse`` axiom::</span>

<span class="sd">            sage: Semigroups().Unital().Inverse()</span>
<span class="sd">            Category of groups</span>

<span class="sd">        or to specify all of them at once, in any order::</span>

<span class="sd">            sage: Semigroups()._with_axioms([&quot;Inverse&quot;, &quot;Unital&quot;])</span>
<span class="sd">            Category of groups</span>
<span class="sd">            sage: Semigroups()._with_axioms([&quot;Unital&quot;, &quot;Inverse&quot;])</span>
<span class="sd">            Category of groups</span>

<span class="sd">            sage: Magmas()._with_axioms([&#39;Commutative&#39;, &#39;Associative&#39;, &#39;Unital&#39;,&#39;Inverse&#39;])</span>
<span class="sd">            Category of commutative groups</span>
<span class="sd">            sage: Magmas()._with_axioms([&#39;Inverse&#39;, &#39;Commutative&#39;, &#39;Associative&#39;, &#39;Unital&#39;])</span>
<span class="sd">            Category of commutative groups</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We repeat adding axioms until they have all been</span>
        <span class="c1"># integrated or nothing happens</span>
        <span class="n">axioms</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">axioms</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">previous</span><span class="p">:</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="n">axioms</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span>
            <span class="n">axioms</span> <span class="o">=</span> <span class="n">axioms</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_without_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the category with axiom ``axiom`` removed.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A category ``C`` which does not have axiom ``axiom``</span>
<span class="sd">        and such that either ``C`` is ``self``, or adding back all the</span>
<span class="sd">        axioms of ``self`` gives back ``self``.</span>

<span class="sd">        .. WARNING:: This is not guaranteed to be robust.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._without_axiom(&quot;Facade&quot;)</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Sets().Facade()._without_axiom(&quot;Facade&quot;)</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Algebras(QQ)._without_axiom(&quot;Unital&quot;)</span>
<span class="sd">            Category of associative algebras over Rational Field</span>
<span class="sd">            sage: Groups()._without_axiom(&quot;Unital&quot;) # todo: not implemented</span>
<span class="sd">            Category of semigroups</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axiom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot remove axiom </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axiom</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_without_axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the category without the axioms that have been added</span>
<span class="sd">        to create it.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``named`` -- a boolean (default: ``False``)</span>

<span class="sd">        .. TODO:: Improve this explanation.</span>

<span class="sd">        If ``named`` is ``True``, then this stops at the first</span>
<span class="sd">        category that has an explicit name of its own. See</span>
<span class="sd">        :meth:`.category_with_axiom.CategoryWithAxiom._without_axioms`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets()._without_axioms()</span>
<span class="sd">            Category of sets</span>
<span class="sd">            sage: Semigroups()._without_axioms()</span>
<span class="sd">            Category of magmas</span>
<span class="sd">            sage: Algebras(QQ).Commutative().WithBasis()._without_axioms()</span>
<span class="sd">            Category of magmatic algebras over Rational Field</span>
<span class="sd">            sage: Algebras(QQ).Commutative().WithBasis()._without_axioms(named=True)</span>
<span class="sd">            Category of algebras over Rational Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_flatten_categories</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_flatten_categories</span><span class="p">)</span>  <span class="c1"># a cythonised helper</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort</span><span class="p">(</span><span class="n">categories</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the categories after sorting them decreasingly according</span>
<span class="sd">        to their comparison key.</span>

<span class="sd">        .. SEEALSO:: :meth:`_cmp_key`</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``categories`` -- a list (or iterable) of non-join categories</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A sorted tuple of categories, possibly with repeats.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The auxiliary function ``_flatten_categories`` used in the test</span>
<span class="sd">            below expects a second argument, which is a type such that</span>
<span class="sd">            instances of that type will be replaced by its super</span>
<span class="sd">            categories. Usually, this type is :class:`JoinCategory`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category._sort([Sets(), Objects(), Coalgebras(QQ), Monoids(), Sets().Finite()])</span>
<span class="sd">            (Category of monoids,</span>
<span class="sd">             Category of coalgebras over Rational Field,</span>
<span class="sd">             Category of finite sets,</span>
<span class="sd">             Category of sets,</span>
<span class="sd">             Category of objects)</span>
<span class="sd">            sage: Category._sort([Sets().Finite(), Semigroups().Finite(), Sets().Facade(),Magmas().Commutative()])</span>
<span class="sd">            (Category of finite semigroups,</span>
<span class="sd">             Category of commutative magmas,</span>
<span class="sd">             Category of finite sets,</span>
<span class="sd">             Category of facade sets)</span>
<span class="sd">            sage: Category._sort(Category._flatten_categories([Sets().Finite(), Algebras(QQ).WithBasis(), Semigroups().Finite(),</span>
<span class="sd">            ....:                                              Sets().Facade(), Algebras(QQ).Commutative(), Algebras(QQ).Graded().WithBasis()],</span>
<span class="sd">            ....:                                              sage.categories.category.JoinCategory))</span>
<span class="sd">            (Category of algebras with basis over Rational Field,</span>
<span class="sd">             Category of algebras with basis over Rational Field,</span>
<span class="sd">             Category of graded algebras over Rational Field,</span>
<span class="sd">             Category of commutative algebras over Rational Field,</span>
<span class="sd">             Category of finite semigroups,</span>
<span class="sd">             Category of finite sets,</span>
<span class="sd">             Category of facade sets)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">category_sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="n">_sort_uniq</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_sort_uniq</span><span class="p">)</span>  <span class="c1"># a cythonised helper</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of two categories.</span>

<span class="sd">        This is just a shortcut for :meth:`join`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets().Finite() &amp; Rings().Commutative()</span>
<span class="sd">            Category of finite commutative rings</span>
<span class="sd">            sage: Monoids() &amp; CommutativeAdditiveMonoids()</span>
<span class="sd">            Join of Category of monoids and Category of commutative additive monoids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the smallest category containing the two categories.</span>

<span class="sd">        This is just a shortcut for :meth:`meet`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Algebras(QQ) | Groups()</span>
<span class="sd">            Category of monoids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">meet</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="n">_join_cache</span> <span class="o">=</span> <span class="n">_join_cache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_axioms</span><span class="o">=</span><span class="p">(),</span> <span class="n">axioms</span><span class="o">=</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the join of the input categories in the lattice of categories.</span>

<span class="sd">        At the level of objects and morphisms, this operation</span>
<span class="sd">        corresponds to intersection: the objects and morphisms of a</span>
<span class="sd">        join category are those that belong to all its super</span>
<span class="sd">        categories.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``categories`` -- a list (or iterable) of categories</span>
<span class="sd">        - ``as_list`` -- a boolean (default: ``False``);</span>
<span class="sd">          whether the result should be returned as a list</span>
<span class="sd">        - ``axioms`` -- a tuple of strings; the names of some</span>
<span class="sd">          supplementary axioms</span>

<span class="sd">        .. SEEALSO:: :meth:`__and__` for a shortcut</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: J = Category.join((Groups(), CommutativeAdditiveMonoids())); J</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>
<span class="sd">            sage: J.super_categories()</span>
<span class="sd">            [Category of groups, Category of commutative additive monoids]</span>
<span class="sd">            sage: J.all_super_categories(proper=True)</span>
<span class="sd">            [Category of groups, ..., Category of magmas,</span>
<span class="sd">             Category of commutative additive monoids, ..., Category of additive magmas,</span>
<span class="sd">             Category of sets, ...]</span>

<span class="sd">        As a short hand, one can use::</span>

<span class="sd">            sage: Groups() &amp; CommutativeAdditiveMonoids()</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>

<span class="sd">        This is a commutative and associative operation::</span>

<span class="sd">            sage: Groups() &amp; Posets()</span>
<span class="sd">            Join of Category of groups and Category of posets</span>
<span class="sd">            sage: Posets() &amp; Groups()</span>
<span class="sd">            Join of Category of groups and Category of posets</span>

<span class="sd">            sage: Groups() &amp; (CommutativeAdditiveMonoids() &amp; Posets())</span>
<span class="sd">            Join of Category of groups</span>
<span class="sd">                and Category of commutative additive monoids</span>
<span class="sd">                and Category of posets</span>
<span class="sd">            sage: (Groups() &amp; CommutativeAdditiveMonoids()) &amp; Posets()</span>
<span class="sd">            Join of Category of groups</span>
<span class="sd">                and Category of commutative additive monoids</span>
<span class="sd">                and Category of posets</span>

<span class="sd">        The join of a single category is the category itself::</span>

<span class="sd">            sage: Category.join([Monoids()])</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        Similarly, the join of several mutually comparable categories is</span>
<span class="sd">        the smallest one::</span>

<span class="sd">            sage: Category.join((Sets(), Rings(), Monoids()))</span>
<span class="sd">            Category of rings</span>

<span class="sd">        In particular, the unit is the top category :class:`Objects`::</span>

<span class="sd">            sage: Groups() &amp; Objects()</span>
<span class="sd">            Category of groups</span>

<span class="sd">        If the optional parameter ``as_list`` is ``True``, this</span>
<span class="sd">        returns the super categories of the join as a list, without</span>
<span class="sd">        constructing the join category itself::</span>

<span class="sd">            sage: Category.join((Groups(), CommutativeAdditiveMonoids()), as_list=True)</span>
<span class="sd">            [Category of groups, Category of commutative additive monoids]</span>
<span class="sd">            sage: Category.join((Sets(), Rings(), Monoids()), as_list=True)</span>
<span class="sd">            [Category of rings]</span>
<span class="sd">            sage: Category.join((Modules(ZZ), FiniteFields()), as_list=True)</span>
<span class="sd">            [Category of finite enumerated fields, Category of modules over Integer Ring]</span>
<span class="sd">            sage: Category.join([], as_list=True)</span>
<span class="sd">            []</span>
<span class="sd">            sage: Category.join([Groups()], as_list=True)</span>
<span class="sd">            [Category of groups]</span>
<span class="sd">            sage: Category.join([Groups() &amp; Posets()], as_list=True)</span>
<span class="sd">            [Category of groups, Category of posets]</span>

<span class="sd">        Support for axiom categories (TODO: put here meaningful examples)::</span>

<span class="sd">            sage: Sets().Facade() &amp; Sets().Infinite()</span>
<span class="sd">            Category of facade infinite sets</span>
<span class="sd">            sage: Magmas().Infinite() &amp; Sets().Facade()</span>
<span class="sd">            Category of facade infinite magmas</span>

<span class="sd">            sage: FiniteSets() &amp; Monoids()</span>
<span class="sd">            Category of finite monoids</span>
<span class="sd">            sage: Rings().Commutative() &amp; Sets().Finite()</span>
<span class="sd">            Category of finite commutative rings</span>

<span class="sd">        Note that several of the above examples are actually join</span>
<span class="sd">        categories; they are just nicely displayed::</span>

<span class="sd">            sage: AlgebrasWithBasis(QQ) &amp; FiniteSets().Algebras(QQ)</span>
<span class="sd">            Join of Category of finite dimensional algebras with basis over Rational Field</span>
<span class="sd">                and Category of finite set algebras over Rational Field</span>

<span class="sd">            sage: UniqueFactorizationDomains() &amp; Algebras(QQ)</span>
<span class="sd">            Join of Category of unique factorization domains</span>
<span class="sd">                and Category of commutative algebras over Rational Field</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: Magmas().Unital().Commutative().Finite() is Magmas().Finite().Commutative().Unital()</span>
<span class="sd">            True</span>
<span class="sd">            sage: from sage.categories.category_with_axiom import TestObjects</span>
<span class="sd">            sage: T = TestObjects()</span>
<span class="sd">            sage: TCF = T.Commutative().Facade(); TCF</span>
<span class="sd">            Category of facade commutative test objects</span>
<span class="sd">            sage: TCF is T.Facade().Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF is (T.Facade() &amp; T.Commutative())</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF.axioms()</span>
<span class="sd">            frozenset({&#39;Commutative&#39;, &#39;Facade&#39;})</span>
<span class="sd">            sage: type(TCF)</span>
<span class="sd">            &lt;class &#39;sage.categories.category_with_axiom.TestObjects.Commutative.Facade_with_category&#39;&gt;</span>

<span class="sd">            sage: TCF = T.Commutative().FiniteDimensional()</span>
<span class="sd">            sage: TCF is T.FiniteDimensional().Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF is T.Commutative() &amp; T.FiniteDimensional()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCF is T.FiniteDimensional() &amp; T.Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: type(TCF)</span>
<span class="sd">            &lt;class &#39;sage.categories.category_with_axiom.TestObjects.Commutative.FiniteDimensional_with_category&#39;&gt;</span>

<span class="sd">            sage: TCU = T.Commutative().Unital()</span>
<span class="sd">            sage: TCU is T.Unital().Commutative()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCU is T.Commutative() &amp; T.Unital()</span>
<span class="sd">            True</span>
<span class="sd">            sage: TCU is T.Unital() &amp; T.Commutative()</span>
<span class="sd">            True</span>

<span class="sd">            sage: TUCF = T.Unital().Commutative().FiniteDimensional(); TUCF</span>
<span class="sd">            Category of finite dimensional commutative unital test objects</span>
<span class="sd">            sage: type(TUCF)</span>
<span class="sd">            &lt;class &#39;sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital.Commutative_with_category&#39;&gt;</span>

<span class="sd">            sage: TFFC = T.Facade().FiniteDimensional().Commutative(); TFFC</span>
<span class="sd">            Category of facade finite dimensional commutative test objects</span>
<span class="sd">            sage: type(TFFC)</span>
<span class="sd">            &lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="sd">            sage: TFFC.super_categories()</span>
<span class="sd">            [Category of facade commutative test objects,</span>
<span class="sd">             Category of finite dimensional commutative test objects]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the list of categories and deal with some trivial cases</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">categories</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Since Objects() is the top category, it is the neutral element of join</span>
                <span class="kn">from</span> <span class="nn">.objects</span> <span class="kn">import</span> <span class="n">Objects</span>
                <span class="k">return</span> <span class="n">Objects</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">categories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">category</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">categories</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">category</span>

        <span class="c1"># Get the cache key, and look into the cache</span>
        <span class="c1"># Ensure associativity and commutativity by flattening</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># - Do we want to store the cache after or before the mangling of the categories?</span>
        <span class="c1"># - Caching with ignore_axioms?</span>
        <span class="c1"># JoinCategory&#39;s sorting, and removing duplicates</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="n">_sort_uniq</span><span class="p">(</span><span class="n">_flatten_categories</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_axioms</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">_join_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">_super_categories</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Handle axioms</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">join_as_tuple</span><span class="p">(</span><span class="n">cache_key</span><span class="p">,</span> <span class="n">axioms</span><span class="p">,</span> <span class="n">ignore_axioms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">JoinCategory</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_axioms</span><span class="p">:</span>
            <span class="n">_join_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">category</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the category of this category. So far, all categories</span>
<span class="sd">        are in the category of objects.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Sets().category()</span>
<span class="sd">            Category of objects</span>
<span class="sd">            sage: VectorSpaces(QQ).category()</span>
<span class="sd">            Category of objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.objects</span> <span class="kn">import</span> <span class="n">Objects</span>
        <span class="k">return</span> <span class="n">Objects</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an object in this category. Most of the time, this is a parent.</span>

<span class="sd">        This serves three purposes:</span>

<span class="sd">        - Give a typical example to better explain what the category is all about.</span>
<span class="sd">          (and by the way prove that the category is non empty :-) )</span>
<span class="sd">        - Provide a minimal template for implementing other objects in this category</span>
<span class="sd">        - Provide an object on which to test generic code implemented by the category</span>

<span class="sd">        For all those applications, the implementation of the object</span>
<span class="sd">        shall be kept to a strict minimum. The object is therefore not</span>
<span class="sd">        meant to be used for other applications; most of the time a</span>
<span class="sd">        full featured version is available elsewhere in Sage, and</span>
<span class="sd">        should be used instead.</span>

<span class="sd">        Technical note: by default ``FooBar(...).example()`` is</span>
<span class="sd">        constructed by looking up</span>
<span class="sd">        ``sage.categories.examples.foo_bar.Example`` and calling it as</span>
<span class="sd">        ``Example()``. Extra positional or named parameters are also</span>
<span class="sd">        passed down. For a category over base ring, the base ring is</span>
<span class="sd">        further passed down as an optional argument.</span>

<span class="sd">        Categories are welcome to override this default implementation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Semigroups().example()</span>
<span class="sd">            An example of a semigroup: the left zero semigroup</span>

<span class="sd">            sage: Monoids().Subquotients().example()</span>
<span class="sd">            NotImplemented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span>
            <span class="c1"># this magic should not apply to nested categories like Monoids.Subquotients</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">module_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;sage.categories&quot;</span><span class="p">,</span> <span class="s2">&quot;sage.categories.examples&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">sys</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">__import__</span><span class="p">(</span><span class="n">module_name</span><span class="p">)</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">Example</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="c1"># Add the base ring as optional argument if this is a category over base ring</span>
        <span class="k">if</span> <span class="s2">&quot;base_ring&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keywords</span><span class="p">[</span><span class="s2">&quot;base_ring&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_Category</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if x is a category.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: sage.categories.category.is_Category(CommutativeAdditiveSemigroups())</span>
<span class="sd">        True</span>
<span class="sd">        sage: sage.categories.category.is_Category(ZZ)</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span>


<span class="nd">@cached_function</span>
<span class="k">def</span> <span class="nf">category_sample</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a sample of categories.</span>

<span class="sd">    It is constructed by looking for all concrete category classes declared in</span>
<span class="sd">    ``sage.categories.all``, calling :meth:`Category.an_instance` on those and</span>
<span class="sd">    taking all their super categories.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from sage.categories.category import category_sample</span>
<span class="sd">        sage: sorted(category_sample(), key=str)                                        # needs sage.groups</span>
<span class="sd">        [Category of Coxeter groups,</span>
<span class="sd">         Category of Dedekind domains,</span>
<span class="sd">         Category of G-sets for Symmetric group of order 8! as a permutation group,</span>
<span class="sd">         Category of Hecke modules over Rational Field,</span>
<span class="sd">         Category of Hopf algebras over Rational Field,</span>
<span class="sd">         Category of Hopf algebras with basis over Rational Field,</span>
<span class="sd">         Category of Lie algebras over Rational Field,</span>
<span class="sd">         Category of Weyl groups,</span>
<span class="sd">         Category of abelian varieties over Rational Field,</span>
<span class="sd">         Category of additive magmas, ...,</span>
<span class="sd">         Category of fields, ...,</span>
<span class="sd">         Category of graded Hopf algebras with basis over Rational Field, ...,</span>
<span class="sd">         Category of modular abelian varieties over Rational Field, ...,</span>
<span class="sd">         Category of simplicial complexes, ...,</span>
<span class="sd">         Category of vector spaces over Rational Field, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sage.categories.all</span>
    <span class="n">abstract_classes_for_categories</span> <span class="o">=</span> <span class="p">[</span><span class="n">Category</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">an_instance</span><span class="p">()</span>
                 <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                 <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Category</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">abstract_classes_for_categories</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">category_graph</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the graph of the categories in Sage.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``categories`` -- a list (or iterable) of categories</span>

<span class="sd">    If ``categories`` is specified, then the graph contains the</span>
<span class="sd">    mentioned categories together with all their super</span>
<span class="sd">    categories. Otherwise the graph contains (an instance of) each</span>
<span class="sd">    category in :mod:`sage.categories.all` (e.g. ``Algebras(QQ)`` for</span>
<span class="sd">    algebras).</span>

<span class="sd">    For readability, the names of the category are shortened.</span>

<span class="sd">    .. TODO:: Further remove the base ring (see also :issue:`15801`).</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: G = sage.categories.category.category_graph(categories=[Groups()])        # needs sage.graphs</span>
<span class="sd">        sage: G.vertices(sort=True)                                                     # needs sage.graphs</span>
<span class="sd">        [&#39;groups&#39;, &#39;inverse unital magmas&#39;, &#39;magmas&#39;, &#39;monoids&#39;, &#39;objects&#39;,</span>
<span class="sd">         &#39;semigroups&#39;, &#39;sets&#39;, &#39;sets with partial maps&#39;, &#39;unital magmas&#39;]</span>
<span class="sd">        sage: G.plot()                                                                  # needs sage.graphs sage.plot</span>
<span class="sd">        Graphics object consisting of 20 graphics primitives</span>

<span class="sd">        sage: sage.categories.category.category_graph().plot()                          # needs sage.graphs sage.plot</span>
<span class="sd">        Graphics object consisting of ... graphics primitives</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sage</span> <span class="kn">import</span> <span class="n">graphs</span>
    <span class="k">if</span> <span class="n">categories</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="n">category_sample</span><span class="p">()</span>
    <span class="c1"># Include all the super categories</span>
    <span class="c1"># Get rid of join categories</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span> <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span>
                  <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">category</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">))}</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">digraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
            <span class="c1"># Don&#39;t use super_categories() since it might contain join categories</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">([</span><span class="n">source</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">(),</span> <span class="n">target</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()])</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="c1">##############################################################################</span>
<span class="c1"># Parametrized categories whose parent/element class depend only on</span>
<span class="c1"># the super categories</span>
<span class="c1">##############################################################################</span>

<span class="k">class</span> <span class="nc">CategoryWithParameters</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parametrized category whose parent/element classes depend only on</span>
<span class="sd">    its super categories.</span>

<span class="sd">    Many categories in Sage are parametrized, like ``C = Algebras(K)``</span>
<span class="sd">    which takes a base ring as parameter. In many cases, however, the</span>
<span class="sd">    operations provided by ``C`` in the parent class and element class</span>
<span class="sd">    depend only on the super categories of ``C``. For example, the</span>
<span class="sd">    vector space operations are provided if and only if ``K`` is a</span>
<span class="sd">    field, since ``VectorSpaces(K)`` is a super category of ``C`` only</span>
<span class="sd">    in that case. In such cases, and as an optimization (see :issue:`11935`),</span>
<span class="sd">    we want to use the same parent and element class for all fields.</span>
<span class="sd">    This is the purpose of this abstract class.</span>

<span class="sd">    Currently, :class:`~sage.categories.category.JoinCategory`,</span>
<span class="sd">    :class:`~sage.categories.category_types.Category_over_base` and</span>
<span class="sd">    :class:`~sage.categories.bimodules.Bimodules` inherit from this</span>
<span class="sd">    class.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: C1 = Algebras(GF(5))</span>
<span class="sd">        sage: C2 = Algebras(GF(3))</span>
<span class="sd">        sage: C3 = Algebras(ZZ)</span>
<span class="sd">        sage: from sage.categories.category import CategoryWithParameters</span>
<span class="sd">        sage: isinstance(C1, CategoryWithParameters)</span>
<span class="sd">        True</span>
<span class="sd">        sage: C1.parent_class is C2.parent_class</span>
<span class="sd">        True</span>
<span class="sd">        sage: C1.parent_class is C3.parent_class</span>
<span class="sd">        False</span>

<span class="sd">    .. automethod:: Category._make_named_class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_make_named_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the parent/element/... class of ``self``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``name`` -- a string; the name of the class as an attribute</span>
<span class="sd">          of ``self``</span>
<span class="sd">        - ``method_provider`` -- a string; the name of an attribute of</span>
<span class="sd">          ``self`` that provides methods for the new class (in</span>
<span class="sd">          addition to what comes from the super categories)</span>
<span class="sd">        - ``**options`` -- other named options to pass down to</span>
<span class="sd">          :meth:`Category._make_named_class`.</span>

<span class="sd">        ASSUMPTION:</span>

<span class="sd">        It is assumed that this method is only called from a lazy</span>
<span class="sd">        attribute whose name coincides with the given ``name``.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A dynamic class that has the corresponding named classes of</span>
<span class="sd">        the super categories of ``self`` as bases and contains the</span>
<span class="sd">        methods provided by ``getattr(self, method_provider)``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This method overrides :meth:`Category._make_named_class`</span>
<span class="sd">            so that the returned class *only* depends on the</span>
<span class="sd">            corresponding named classes of the super categories and on</span>
<span class="sd">            the provided methods. This allows for sharing the named</span>
<span class="sd">            classes across closely related categories providing the</span>
<span class="sd">            same code to their parents, elements and so on.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The categories of bimodules over the fields ``CC`` or ``RR``</span>
<span class="sd">        provide the same methods to their parents and elements::</span>

<span class="sd">            sage: Bimodules(ZZ,RR).parent_class is Bimodules(ZZ,RDF).parent_class  # indirect doctest</span>
<span class="sd">            True</span>
<span class="sd">            sage: Bimodules(CC,ZZ).element_class is Bimodules(RR,ZZ).element_class      # needs sage.rings.real_mpfr</span>
<span class="sd">            True</span>

<span class="sd">        On the other hand, modules over a field have more methods than</span>
<span class="sd">        modules over a ring::</span>

<span class="sd">            sage: Modules(GF(3)).parent_class is Modules(ZZ).parent_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: Modules(GF(3)).element_class is Modules(ZZ).element_class</span>
<span class="sd">            False</span>

<span class="sd">        For a more subtle example, one could possibly share the classes for</span>
<span class="sd">        ``GF(3)`` and ``GF(2^3, &#39;x&#39;)``, but this is not currently the case::</span>

<span class="sd">            sage: Modules(GF(3)).parent_class is Modules(GF(2^3,&#39;x&#39;)).parent_class      # needs sage.rings.finite_rings</span>
<span class="sd">            False</span>

<span class="sd">        This is because those two fields do not have the exact same category::</span>

<span class="sd">            sage: GF(3).category()</span>
<span class="sd">            Join of Category of finite enumerated fields</span>
<span class="sd">             and Category of subquotients of monoids</span>
<span class="sd">             and Category of quotients of semigroups</span>
<span class="sd">            sage: GF(2^3,&#39;x&#39;).category()                                                # needs sage.rings.finite_rings</span>
<span class="sd">            Category of finite enumerated fields</span>

<span class="sd">        Similarly for ``QQ`` and ``RR``::</span>

<span class="sd">            sage: QQ.category()</span>
<span class="sd">            Join of Category of number fields</span>
<span class="sd">             and Category of quotient fields</span>
<span class="sd">             and Category of metric spaces</span>
<span class="sd">            sage: RR.category()</span>
<span class="sd">            Join of Category of fields and Category of infinite sets</span>
<span class="sd">                and Category of complete metric spaces</span>
<span class="sd">            sage: Modules(QQ).parent_class is Modules(RR).parent_class</span>
<span class="sd">            False</span>

<span class="sd">        Some other cases where one could potentially share those classes::</span>

<span class="sd">            sage: MF = Modules(GF(3), dispatch=False)</span>
<span class="sd">            sage: MF.parent_class is Modules(ZZ).parent_class</span>
<span class="sd">            False</span>
<span class="sd">            sage: MF.element_class is Modules(ZZ).element_class</span>
<span class="sd">            False</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: PC = Algebras(QQ).parent_class; PC   # indirect doctest</span>
<span class="sd">            &lt;class &#39;sage.categories.algebras.Algebras.parent_class&#39;&gt;</span>
<span class="sd">            sage: type(PC)</span>
<span class="sd">            &lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
<span class="sd">            sage: PC.__bases__</span>
<span class="sd">            (&lt;class &#39;sage.categories.rings.Rings.parent_class&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;sage.categories.associative_algebras.AssociativeAlgebras.parent_class&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;sage.categories.unital_algebras.UnitalAlgebras.parent_class&#39;&gt;)</span>
<span class="sd">            sage: loads(dumps(PC)) is PC</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DynamicMetaclass</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__base__</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class_key</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method_provider</span><span class="p">,</span>
                                            <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_named_class_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@abstract_method</span>
    <span class="k">def</span> <span class="nf">_make_named_class_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return what the element/parent/... class depend on.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``name`` -- a string; the name of the class as an attribute</span>
<span class="sd">          of ``self``</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`_make_named_class`</span>
<span class="sd">            - :meth:`sage.categories.category_types.Category_over_base._make_named_class_key`</span>
<span class="sd">            - :meth:`sage.categories.bimodules.Bimodules._make_named_class_key`</span>
<span class="sd">            - :meth:`JoinCategory._make_named_class_key`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The parent class of an algebra depends only on the category of the base ring::</span>

<span class="sd">            sage: Algebras(ZZ)._make_named_class_key(&quot;parent_class&quot;)</span>
<span class="sd">            Join of Category of Dedekind domains</span>
<span class="sd">                 and Category of euclidean domains</span>
<span class="sd">                 and Category of infinite enumerated sets</span>
<span class="sd">                 and Category of metric spaces</span>

<span class="sd">        The morphism class of a bimodule depends only on the category</span>
<span class="sd">        of the left and right base rings::</span>

<span class="sd">            sage: Bimodules(QQ, ZZ)._make_named_class_key(&quot;morphism_class&quot;)</span>
<span class="sd">            (Join of Category of number fields</span>
<span class="sd">                 and Category of quotient fields</span>
<span class="sd">                 and Category of metric spaces,</span>
<span class="sd">             Join of Category of Dedekind domains</span>
<span class="sd">                 and Category of euclidean domains</span>
<span class="sd">                 and Category of infinite enumerated sets</span>
<span class="sd">                 and Category of metric spaces)</span>

<span class="sd">        The element class of a join category depends only on the</span>
<span class="sd">        element class of its super categories::</span>

<span class="sd">            sage: Category.join([Groups(), Posets()])._make_named_class_key(&quot;element_class&quot;)</span>
<span class="sd">            (&lt;class &#39;sage.categories.groups.Groups.element_class&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;sage.categories.posets.Posets.element_class&#39;&gt;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="n">_make_named_class_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">_cmp_key</span> <span class="o">=</span> <span class="n">_cmp_key_named</span>

    <span class="k">def</span> <span class="nf">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A quick but partial test whether ``C`` is a subcategory of ``self``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``C`` -- a category</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        ``False``, if ``C.parent_class`` is not a subclass of</span>
<span class="sd">        ``self.parent_class``, and :obj:`~sage.misc.unknown.Unknown`</span>
<span class="sd">        otherwise.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Bimodules(QQ,QQ)._subcategory_hook_(Modules(QQ))</span>
<span class="sd">            Unknown</span>
<span class="sd">            sage: Bimodules(QQ,QQ)._subcategory_hook_(Rings())</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_class</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">Unknown</span>


<span class="c1">#############################################################</span>
<span class="c1"># Join of several categories</span>
<span class="c1">#############################################################</span>

<span class="k">class</span> <span class="nc">JoinCategory</span><span class="p">(</span><span class="n">CategoryWithParameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for joins of several categories. Do not use directly;</span>
<span class="sd">    see Category.join instead.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from sage.categories.category import JoinCategory</span>
<span class="sd">        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J</span>
<span class="sd">        Join of Category of groups and Category of commutative additive monoids</span>
<span class="sd">        sage: J.super_categories()</span>
<span class="sd">        [Category of groups, Category of commutative additive monoids]</span>
<span class="sd">        sage: J.all_super_categories(proper=True)</span>
<span class="sd">        [Category of groups, ..., Category of magmas,</span>
<span class="sd">         Category of commutative additive monoids, ..., Category of additive magmas,</span>
<span class="sd">         Category of sets, Category of sets with partial maps, Category of objects]</span>

<span class="sd">    By :issue:`11935`, join categories and categories over base rings</span>
<span class="sd">    inherit from :class:`CategoryWithParameters`. This allows for</span>
<span class="sd">    sharing parent and element classes between similar categories. For</span>
<span class="sd">    example, since group algebras belong to a join category and since</span>
<span class="sd">    the underlying implementation is the same for all finite fields,</span>
<span class="sd">    we have::</span>

<span class="sd">        sage: # needs sage.groups sage.rings.finite_rings</span>
<span class="sd">        sage: G = SymmetricGroup(10)</span>
<span class="sd">        sage: A3 = G.algebra(GF(3))</span>
<span class="sd">        sage: A5 = G.algebra(GF(5))</span>
<span class="sd">        sage: type(A3.category())</span>
<span class="sd">        &lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="sd">        sage: type(A3) is type(A5)</span>
<span class="sd">        True</span>

<span class="sd">    .. automethod:: Category._repr_object_names</span>
<span class="sd">    .. automethod:: Category._repr_</span>
<span class="sd">    .. automethod:: Category._without_axioms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">super_categories</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes this JoinCategory</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``super_categories`` -- Categories to join. This category will</span>
<span class="sd">          consist of objects and morphisms that lie in all of these</span>
<span class="sd">          categories.</span>

<span class="sd">        - ``name`` -- ignored</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from sage.categories.category import JoinCategory</span>
<span class="sd">            sage: C = JoinCategory((Groups(), CommutativeAdditiveMonoids())); C</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>
<span class="sd">            sage: TestSuite(C).run()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">super_categories</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">JoinCategory</span><span class="p">)</span> <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">super_categories</span><span class="p">)</span>
        <span class="c1"># Use __super_categories to not overwrite the lazy attribute Category._super_categories</span>
        <span class="c1"># Maybe this would not be needed if the flattening/sorting is does consistently?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__super_categories</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">super_categories</span><span class="p">)</span>
        <span class="n">Category</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_named_class_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return what the element/parent/... classes depend on.</span>

<span class="sd">        Since :issue:`11935`, the element/parent classes of a join</span>
<span class="sd">        category over base only depend on the element/parent class of</span>
<span class="sd">        its super categories.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`CategoryWithParameters`</span>
<span class="sd">            - :meth:`CategoryWithParameters._make_named_class_key`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Modules(ZZ)._make_named_class_key(&#39;element_class&#39;)</span>
<span class="sd">            Join of Category of Dedekind domains</span>
<span class="sd">                 and Category of euclidean domains</span>
<span class="sd">                 and Category of infinite enumerated sets</span>
<span class="sd">                 and Category of metric spaces</span>
<span class="sd">            sage: Modules(QQ)._make_named_class_key(&#39;parent_class&#39;)</span>
<span class="sd">            Join of Category of number fields</span>
<span class="sd">             and Category of quotient fields</span>
<span class="sd">             and Category of metric spaces</span>
<span class="sd">            sage: Schemes(Spec(ZZ))._make_named_class_key(&#39;parent_class&#39;)</span>
<span class="sd">            Category of schemes</span>
<span class="sd">            sage: ModularAbelianVarieties(QQ)._make_named_class_key(&#39;parent_class&#39;)</span>
<span class="sd">            Join of Category of number fields</span>
<span class="sd">             and Category of quotient fields</span>
<span class="sd">             and Category of metric spaces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the immediate super categories, as per :meth:`Category.super_categories`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from sage.categories.category import JoinCategory</span>
<span class="sd">            sage: JoinCategory((Semigroups(), FiniteEnumeratedSets())).super_categories()</span>
<span class="sd">            [Category of semigroups, Category of finite enumerated sets]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__super_categories</span>

    <span class="k">def</span> <span class="nf">additional_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``None``.</span>

<span class="sd">        Indeed, a join category defines no additional structure.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category.additional_structure`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Modules(ZZ).additional_structure()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether ``category`` is a subcategory of this join category</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``category`` -- a category.</span>

<span class="sd">        .. note::</span>

<span class="sd">            ``category`` is a sub-category of this join category if</span>
<span class="sd">            and only if it is a sub-category of all super categories</span>
<span class="sd">            of this join category.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: base_cat = Category.join([NumberFields(), QuotientFields().Metric()])</span>
<span class="sd">            sage: cat = Category.join([Rings(), VectorSpaces(base_cat)])</span>
<span class="sd">            sage: QQ[&#39;x&#39;].category().is_subcategory(cat)  # indirect doctest</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">category</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_subcategory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether this join category is subcategory of another</span>
<span class="sd">        category ``C``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category.join([Rings(),Modules(QQ)]).is_subcategory(Category.join([Rngs(),Bimodules(QQ,QQ)]))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">hook</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="n">Unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hook</span>

    <span class="k">def</span> <span class="nf">_with_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the category obtained by adding an axiom to ``self``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This is just an optimization of</span>
<span class="sd">            :meth:`Category._with_axiom`; it&#39;s not necessarily</span>
<span class="sd">            actually useful.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Category.join([Monoids(), Posets()])</span>
<span class="sd">            sage: C._with_axioms([&quot;Finite&quot;])</span>
<span class="sd">            Join of Category of finite monoids and Category of finite posets</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Check that axiom categories for a join are reconstructed from</span>
<span class="sd">        the base categories::</span>

<span class="sd">            sage: C = Category.join([Monoids(), Magmas().Commutative()])</span>
<span class="sd">            sage: C._with_axioms([&quot;Finite&quot;])</span>
<span class="sd">            Category of finite commutative monoids</span>

<span class="sd">        This helps guaranteeing commutativity of taking axioms::</span>

<span class="sd">            sage: Monoids().Finite().Commutative() is Monoids().Commutative().Finite()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">cat</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">])</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_without_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this category with axiom ``axiom`` removed.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A category ``C`` which does not have axiom ``axiom`` and such</span>
<span class="sd">        that either ``C`` is ``self``, or adding back all the</span>
<span class="sd">        axioms of ``self`` gives back ``self``.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category._without_axiom`</span>

<span class="sd">        .. WARNING:: This is not guaranteed to be robust.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Posets() &amp; FiniteEnumeratedSets() &amp; Sets().Facade(); C</span>
<span class="sd">            Category of facade finite enumerated posets</span>
<span class="sd">            sage: C._without_axiom(&quot;Facade&quot;)</span>
<span class="sd">            Category of finite enumerated posets</span>

<span class="sd">            sage: C = Sets().Finite().Facade()</span>
<span class="sd">            sage: type(C)</span>
<span class="sd">            &lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="sd">            sage: C._without_axiom(&quot;Facade&quot;)</span>
<span class="sd">            Category of finite sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_without_axiom</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span> <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_categories</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">axiom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">_with_axioms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_without_axioms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When adjoining axioms to a category, one often gets a join</span>
<span class="sd">        category; this method tries to recover the original</span>
<span class="sd">        category from this join category.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``named`` -- a boolean (default: ``False``)</span>

<span class="sd">        See :meth:`Category._without_axioms` for the description</span>
<span class="sd">        of the ``named`` parameter.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: C = Category.join([Monoids(), Posets()]).Finite()</span>
<span class="sd">            sage: C._repr_(as_join=True)</span>
<span class="sd">            &#39;Join of Category of finite monoids and Category of finite posets&#39;</span>
<span class="sd">            sage: C._without_axioms()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: This join category isn&#39;t built by adding axioms to a single category</span>
<span class="sd">            sage: C = Monoids().Infinite()</span>
<span class="sd">            sage: C._repr_(as_join=True)</span>
<span class="sd">            &#39;Join of Category of monoids and Category of infinite sets&#39;</span>
<span class="sd">            sage: C._without_axioms()</span>
<span class="sd">            Category of magmas</span>
<span class="sd">            sage: C._without_axioms(named=True)</span>
<span class="sd">            Category of monoids</span>

<span class="sd">        TESTS:</span>

<span class="sd">        ``C`` is in fact a join category::</span>

<span class="sd">            sage: from sage.categories.category import JoinCategory</span>
<span class="sd">            sage: isinstance(C, JoinCategory)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axioms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">category</span><span class="o">.</span><span class="n">_with_axioms</span><span class="p">(</span><span class="n">axioms</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">category</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="n">named</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This join category isn&#39;t built by adding axioms&quot;</span>
                         <span class="s2">&quot; to a single category&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cmp_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a comparison key for ``self``.</span>

<span class="sd">        See :meth:`Category._cmp_key` for the specifications.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        This raises an error since ``_cmp_key`` should not be called</span>
<span class="sd">        on join categories::</span>

<span class="sd">            sage: (Magmas() &amp; CommutativeAdditiveSemigroups())._cmp_key()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: _cmp_key should not be called on join categories</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_cmp_key should not be called on join categories&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_object_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the name of the objects of this category.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category._repr_object_names`, :meth:`_repr_`, :meth:`._without_axioms`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Groups().Finite().Commutative()._repr_(as_join=True)</span>
<span class="sd">            &#39;Join of Category of finite groups and Category of commutative groups&#39;</span>
<span class="sd">            sage: Groups().Finite().Commutative()._repr_object_names()</span>
<span class="sd">            &#39;finite commutative groups&#39;</span>

<span class="sd">        This uses :meth:`._without_axioms` which may fail if this</span>
<span class="sd">        category is not obtained by adjoining axioms to some super</span>
<span class="sd">        categories::</span>

<span class="sd">            sage: Category.join((Groups(), CommutativeAdditiveMonoids()))._repr_object_names()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: This join category isn&#39;t built by adding axioms to a single category</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">CategoryWithAxiom</span>
        <span class="k">return</span> <span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names_static</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_join</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print representation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_join`` -- a boolean (default: False)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: Category.join((Groups(), CommutativeAdditiveMonoids())) #indirect doctest</span>
<span class="sd">            Join of Category of groups and Category of commutative additive monoids</span>

<span class="sd">        By default, when a join category is built from category by</span>
<span class="sd">        adjoining axioms, a nice name is printed out::</span>

<span class="sd">            sage: Groups().Facade().Finite()</span>
<span class="sd">            Category of facade finite groups</span>

<span class="sd">        But this is in fact really a join category::</span>

<span class="sd">            sage: Groups().Facade().Finite()._repr_(as_join = True)</span>
<span class="sd">            &#39;Join of Category of finite groups and Category of facade sets&#39;</span>

<span class="sd">        The rationale is to make it more readable, and hide the</span>
<span class="sd">        technical details of how this category is constructed</span>
<span class="sd">        internally, especially since this construction is likely to</span>
<span class="sd">        change over time when new axiom categories are implemented.</span>

<span class="sd">        This join category may possibly be obtained by adding axioms</span>
<span class="sd">        to different categories; so the result is not guaranteed to be</span>
<span class="sd">        unique; when this is not the case the first found is used.</span>

<span class="sd">        .. SEEALSO:: :meth:`Category._repr_`, :meth:`_repr_object_names`</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: Category.join((Sets().Facade(), Groups()))</span>
<span class="sd">            Category of facade groups</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_join</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="s2">&quot;Join of &quot;</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_super_categories</span><span class="p">)</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pieter Belmans
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021, Pieter Belmans.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>